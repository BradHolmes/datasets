/*
NCBI Datasets API

### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated bag](https://www.ncbi.nlm.nih.gov/datasets/docs/rehydrate/), and retrieve the individual data files at a later time. 

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package datasets

import (
	"encoding/json"
	"fmt"
)

// V1CountType the model 'V1CountType'
type V1CountType string

// List of v1CountType
const (
	V1COUNTTYPE_UNSPECIFIED V1CountType = "COUNT_TYPE_UNSPECIFIED"
	V1COUNTTYPE_ASSEMBLY V1CountType = "COUNT_TYPE_ASSEMBLY"
	V1COUNTTYPE_GENE V1CountType = "COUNT_TYPE_GENE"
	V1COUNTTYPE_T_RNA V1CountType = "COUNT_TYPE_tRNA"
	V1COUNTTYPE_R_RNA V1CountType = "COUNT_TYPE_rRNA"
	V1COUNTTYPE_SN_RNA V1CountType = "COUNT_TYPE_snRNA"
	V1COUNTTYPE_SC_RNA V1CountType = "COUNT_TYPE_scRNA"
	V1COUNTTYPE_SNO_RNA V1CountType = "COUNT_TYPE_snoRNA"
	V1COUNTTYPE_PROTEIN_CODING V1CountType = "COUNT_TYPE_PROTEIN_CODING"
	V1COUNTTYPE_PSEUDO V1CountType = "COUNT_TYPE_PSEUDO"
	V1COUNTTYPE_TRANSPOSON V1CountType = "COUNT_TYPE_TRANSPOSON"
	V1COUNTTYPE_MISC_RNA V1CountType = "COUNT_TYPE_miscRNA"
	V1COUNTTYPE_NC_RNA V1CountType = "COUNT_TYPE_ncRNA"
	V1COUNTTYPE_BIOLOGICAL_REGION V1CountType = "COUNT_TYPE_BIOLOGICAL_REGION"
	V1COUNTTYPE_OTHER V1CountType = "COUNT_TYPE_OTHER"
)

// All allowed values of V1CountType enum
var AllowedV1CountTypeEnumValues = []V1CountType{
	"COUNT_TYPE_UNSPECIFIED",
	"COUNT_TYPE_ASSEMBLY",
	"COUNT_TYPE_GENE",
	"COUNT_TYPE_tRNA",
	"COUNT_TYPE_rRNA",
	"COUNT_TYPE_snRNA",
	"COUNT_TYPE_scRNA",
	"COUNT_TYPE_snoRNA",
	"COUNT_TYPE_PROTEIN_CODING",
	"COUNT_TYPE_PSEUDO",
	"COUNT_TYPE_TRANSPOSON",
	"COUNT_TYPE_miscRNA",
	"COUNT_TYPE_ncRNA",
	"COUNT_TYPE_BIOLOGICAL_REGION",
	"COUNT_TYPE_OTHER",
}

func (v *V1CountType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := V1CountType(value)
	for _, existing := range AllowedV1CountTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid V1CountType", value)
}

// NewV1CountTypeFromValue returns a pointer to a valid V1CountType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewV1CountTypeFromValue(v string) (*V1CountType, error) {
	ev := V1CountType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for V1CountType: valid values are %v", v, AllowedV1CountTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v V1CountType) IsValid() bool {
	for _, existing := range AllowedV1CountTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to v1CountType value
func (v V1CountType) Ptr() *V1CountType {
	return &v
}

type NullableV1CountType struct {
	value *V1CountType
	isSet bool
}

func (v NullableV1CountType) Get() *V1CountType {
	return v.value
}

func (v *NullableV1CountType) Set(val *V1CountType) {
	v.value = val
	v.isSet = true
}

func (v NullableV1CountType) IsSet() bool {
	return v.isSet
}

func (v *NullableV1CountType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableV1CountType(val *V1CountType) *NullableV1CountType {
	return &NullableV1CountType{value: val, isSet: true}
}

func (v NullableV1CountType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableV1CountType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

