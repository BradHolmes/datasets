/*
NCBI Datasets API

### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated bag](https://www.ncbi.nlm.nih.gov/datasets/docs/rehydrate/), and retrieve the individual data files at a later time. 

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package datasets

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
	"time"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// GenomeApiService GenomeApi service
type GenomeApiService service

type ApiAssemblyDescriptorsByAccessionsRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	accessions []string	
	filtersReferenceOnly *bool	
	filtersAssemblySource *V1AssemblyDatasetDescriptorsFilterAssemblySource	
	filtersHasAnnotation *bool	
	filtersAssemblyLevel *[]V1AssemblyDatasetDescriptorsFilterAssemblyLevel	
	filtersFirstReleaseDate *time.Time	
	filtersLastReleaseDate *time.Time	
	filtersSearchText *[]string	
	pageSize *int32	
	pageToken *string	
    Headers map[string]string
}

// If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersReferenceOnly(filtersReferenceOnly bool) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}
// Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersAssemblySource(filtersAssemblySource V1AssemblyDatasetDescriptorsFilterAssemblySource) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}
// Return only annotated genome assemblies
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersHasAnnotation(filtersHasAnnotation bool) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}
// Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V1AssemblyDatasetDescriptorsFilterAssemblyLevel) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}
// Only return genome assemblies that were released on or after the specified date By default, do not filter.
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}
// Only return genome assemblies that were released on or before to the specified date By default, do not filter.
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}
// Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersSearchText(filtersSearchText []string) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}
// The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size,  &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r *ApiAssemblyDescriptorsByAccessionsRequest) PageSize(pageSize int32) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.pageSize = &pageSize
	return r
}
// A page token is returned from an &#x60;AssemblyMetadataRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous  &#x60;AssemblyMetadataRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r *ApiAssemblyDescriptorsByAccessionsRequest) PageToken(pageToken string) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiAssemblyDescriptorsByAccessionsRequest) Execute() (V1AssemblyMetadata, *_nethttp.Response, error) {
	return r.ApiService.AssemblyDescriptorsByAccessionsExecute(r)
}

/*
AssemblyDescriptorsByAccessions Get genome metadata by accession

Get detailed metadata for assembled genomes by accession in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions
 @return ApiAssemblyDescriptorsByAccessionsRequest
*/
func (a *GenomeApiService) AssemblyDescriptorsByAccessions(ctx _context.Context, accessions []string) ApiAssemblyDescriptorsByAccessionsRequest {
	return ApiAssemblyDescriptorsByAccessionsRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V1AssemblyMetadata
func (a *GenomeApiService) AssemblyDescriptorsByAccessionsExecute(r ApiAssemblyDescriptorsByAccessionsRequest) (V1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AssemblyDescriptorsByAccessions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssemblyDescriptorsByBioprojectRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	accessions []string	
	filtersReferenceOnly *bool	
	filtersAssemblySource *V1AssemblyDatasetDescriptorsFilterAssemblySource	
	filtersHasAnnotation *bool	
	filtersAssemblyLevel *[]V1AssemblyDatasetDescriptorsFilterAssemblyLevel	
	filtersFirstReleaseDate *time.Time	
	filtersLastReleaseDate *time.Time	
	filtersSearchText *[]string	
	returnedContent *V1AssemblyMetadataRequestContentType	
	pageSize *int32	
	pageToken *string	
    Headers map[string]string
}

// If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersReferenceOnly(filtersReferenceOnly bool) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}
// Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersAssemblySource(filtersAssemblySource V1AssemblyDatasetDescriptorsFilterAssemblySource) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}
// Return only annotated genome assemblies
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersHasAnnotation(filtersHasAnnotation bool) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}
// Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V1AssemblyDatasetDescriptorsFilterAssemblyLevel) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}
// Only return genome assemblies that were released on or after the specified date By default, do not filter.
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}
// Only return genome assemblies that were released on or before to the specified date By default, do not filter.
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}
// Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersSearchText(filtersSearchText []string) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}
// Return either assembly accessions, or entire assembly-metadata records
func (r *ApiAssemblyDescriptorsByBioprojectRequest) ReturnedContent(returnedContent V1AssemblyMetadataRequestContentType) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.returnedContent = &returnedContent
	return r
}
// The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size,  &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r *ApiAssemblyDescriptorsByBioprojectRequest) PageSize(pageSize int32) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.pageSize = &pageSize
	return r
}
// A page token is returned from an &#x60;AssemblyMetadataRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous  &#x60;AssemblyMetadataRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r *ApiAssemblyDescriptorsByBioprojectRequest) PageToken(pageToken string) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiAssemblyDescriptorsByBioprojectRequest) Execute() (V1AssemblyMetadata, *_nethttp.Response, error) {
	return r.ApiService.AssemblyDescriptorsByBioprojectExecute(r)
}

/*
AssemblyDescriptorsByBioproject Get genome metadata by bioproject accession

Get detailed metadata for assembled genomes by bioproject accession in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions
 @return ApiAssemblyDescriptorsByBioprojectRequest
*/
func (a *GenomeApiService) AssemblyDescriptorsByBioproject(ctx _context.Context, accessions []string) ApiAssemblyDescriptorsByBioprojectRequest {
	return ApiAssemblyDescriptorsByBioprojectRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V1AssemblyMetadata
func (a *GenomeApiService) AssemblyDescriptorsByBioprojectExecute(r ApiAssemblyDescriptorsByBioprojectRequest) (V1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AssemblyDescriptorsByBioproject")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/bioproject/{accessions}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssemblyDescriptorsByTaxonRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	taxon string	
	filtersReferenceOnly *bool	
	filtersAssemblySource *V1AssemblyDatasetDescriptorsFilterAssemblySource	
	filtersHasAnnotation *bool	
	filtersAssemblyLevel *[]V1AssemblyDatasetDescriptorsFilterAssemblyLevel	
	filtersFirstReleaseDate *time.Time	
	filtersLastReleaseDate *time.Time	
	filtersSearchText *[]string	
	taxExactMatch *bool	
	returnedContent *V1AssemblyMetadataRequestContentType	
	pageSize *int32	
	pageToken *string	
    Headers map[string]string
}

// If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersReferenceOnly(filtersReferenceOnly bool) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}
// Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersAssemblySource(filtersAssemblySource V1AssemblyDatasetDescriptorsFilterAssemblySource) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}
// Return only annotated genome assemblies
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersHasAnnotation(filtersHasAnnotation bool) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}
// Only return genome assemblies that have one of the specified assembly levels. By default, do not filter.
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V1AssemblyDatasetDescriptorsFilterAssemblyLevel) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}
// Only return genome assemblies that were released on or after the specified date By default, do not filter.
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}
// Only return genome assemblies that were released on or before to the specified date By default, do not filter.
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}
// Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields By default, do not filter
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersSearchText(filtersSearchText []string) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}
// If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. Ignored for assembly_accession request.
func (r *ApiAssemblyDescriptorsByTaxonRequest) TaxExactMatch(taxExactMatch bool) *ApiAssemblyDescriptorsByTaxonRequest {
	r.taxExactMatch = &taxExactMatch
	return r
}
// Return either assembly accessions, or entire assembly-metadata records
func (r *ApiAssemblyDescriptorsByTaxonRequest) ReturnedContent(returnedContent V1AssemblyMetadataRequestContentType) *ApiAssemblyDescriptorsByTaxonRequest {
	r.returnedContent = &returnedContent
	return r
}
// The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size,  &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r *ApiAssemblyDescriptorsByTaxonRequest) PageSize(pageSize int32) *ApiAssemblyDescriptorsByTaxonRequest {
	r.pageSize = &pageSize
	return r
}
// A page token is returned from an &#x60;AssemblyMetadataRequest&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous  &#x60;AssemblyMetadataRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r *ApiAssemblyDescriptorsByTaxonRequest) PageToken(pageToken string) *ApiAssemblyDescriptorsByTaxonRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiAssemblyDescriptorsByTaxonRequest) Execute() (V1AssemblyMetadata, *_nethttp.Response, error) {
	return r.ApiService.AssemblyDescriptorsByTaxonExecute(r)
}

/*
AssemblyDescriptorsByTaxon Get genome metadata by taxonomic identifier

Get detailed metadata on all assembled genomes for a specified NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return ApiAssemblyDescriptorsByTaxonRequest
*/
func (a *GenomeApiService) AssemblyDescriptorsByTaxon(ctx _context.Context, taxon string) ApiAssemblyDescriptorsByTaxonRequest {
	return ApiAssemblyDescriptorsByTaxonRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V1AssemblyMetadata
func (a *GenomeApiService) AssemblyDescriptorsByTaxonExecute(r ApiAssemblyDescriptorsByTaxonRequest) (V1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AssemblyDescriptorsByTaxon")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/taxon/{taxon}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.taxExactMatch != nil {
		localVarQueryParams.Add("tax_exact_match", parameterToString(*r.taxExactMatch, ""))
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckAssemblyAvailabilityRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	accessions []string	
    Headers map[string]string
}


func (r ApiCheckAssemblyAvailabilityRequest) Execute() (V1AssemblyDatasetAvailability, *_nethttp.Response, error) {
	return r.ApiService.CheckAssemblyAvailabilityExecute(r)
}

/*
CheckAssemblyAvailability Check the validity of genome accessions

The 'GET' version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions NCBI genome assembly accessions
 @return ApiCheckAssemblyAvailabilityRequest
*/
func (a *GenomeApiService) CheckAssemblyAvailability(ctx _context.Context, accessions []string) ApiCheckAssemblyAvailabilityRequest {
	return ApiCheckAssemblyAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V1AssemblyDatasetAvailability
func (a *GenomeApiService) CheckAssemblyAvailabilityExecute(r ApiCheckAssemblyAvailabilityRequest) (V1AssemblyDatasetAvailability, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyDatasetAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.CheckAssemblyAvailability")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/check"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckAssemblyAvailabilityPostRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	v1AssemblyDatasetRequest *V1AssemblyDatasetRequest	
    Headers map[string]string
}

func (r *ApiCheckAssemblyAvailabilityPostRequest) V1AssemblyDatasetRequest(v1AssemblyDatasetRequest V1AssemblyDatasetRequest) *ApiCheckAssemblyAvailabilityPostRequest {
	r.v1AssemblyDatasetRequest = &v1AssemblyDatasetRequest
	return r
}

func (r ApiCheckAssemblyAvailabilityPostRequest) Execute() (V1AssemblyDatasetAvailability, *_nethttp.Response, error) {
	return r.ApiService.CheckAssemblyAvailabilityPostExecute(r)
}

/*
CheckAssemblyAvailabilityPost Check the validity of many genome accessions in a single request

The 'GET' version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCheckAssemblyAvailabilityPostRequest
*/
func (a *GenomeApiService) CheckAssemblyAvailabilityPost(ctx _context.Context, v1AssemblyDatasetRequest *V1AssemblyDatasetRequest) ApiCheckAssemblyAvailabilityPostRequest {
	return ApiCheckAssemblyAvailabilityPostRequest{
		ApiService: a,
		ctx: ctx,
		v1AssemblyDatasetRequest: v1AssemblyDatasetRequest,
	}
}

// Execute executes the request
//  @return V1AssemblyDatasetAvailability
func (a *GenomeApiService) CheckAssemblyAvailabilityPostExecute(r ApiCheckAssemblyAvailabilityPostRequest) (V1AssemblyDatasetAvailability, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyDatasetAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.CheckAssemblyAvailabilityPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/check"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1AssemblyDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1AssemblyDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1AssemblyDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadAssemblyPackageRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	accessions []string	
	chromosomes *[]string	
	excludeSequence *bool	
	includeAnnotationType *[]V1AnnotationForAssemblyType	
	hydrated *V1AssemblyDatasetRequestResolution	
	filename *string	
    Headers map[string]string
}

// The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome (&#39;Un&#39;). The filter only applies to fasta sequence.
func (r *ApiDownloadAssemblyPackageRequest) Chromosomes(chromosomes []string) *ApiDownloadAssemblyPackageRequest {
	r.chromosomes = &chromosomes
	return r
}
// Set to true to omit the genomic sequence.
func (r *ApiDownloadAssemblyPackageRequest) ExcludeSequence(excludeSequence bool) *ApiDownloadAssemblyPackageRequest {
	r.excludeSequence = &excludeSequence
	return r
}
// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r *ApiDownloadAssemblyPackageRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForAssemblyType) *ApiDownloadAssemblyPackageRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}
// Set to DATA_REPORT_ONLY, to only retrieve data-reports.
func (r *ApiDownloadAssemblyPackageRequest) Hydrated(hydrated V1AssemblyDatasetRequestResolution) *ApiDownloadAssemblyPackageRequest {
	r.hydrated = &hydrated
	return r
}
// Output file name.
func (r *ApiDownloadAssemblyPackageRequest) Filename(filename string) *ApiDownloadAssemblyPackageRequest {
	r.filename = &filename
	return r
}

func (r ApiDownloadAssemblyPackageRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DownloadAssemblyPackageExecute(r)
}

/*
DownloadAssemblyPackage Get a genome dataset by accession

Download a genome dataset including fasta sequence, annotation and a detailed data report by accession.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions NCBI genome assembly accessions
 @return ApiDownloadAssemblyPackageRequest
*/
func (a *GenomeApiService) DownloadAssemblyPackage(ctx _context.Context, accessions []string) ApiDownloadAssemblyPackageRequest {
	return ApiDownloadAssemblyPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return *os.File
func (a *GenomeApiService) DownloadAssemblyPackageExecute(r ApiDownloadAssemblyPackageRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.DownloadAssemblyPackage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.chromosomes != nil {
		t := *r.chromosomes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("chromosomes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("chromosomes", parameterToString(t, "multi"))
		}
	}
	if r.excludeSequence != nil {
		localVarQueryParams.Add("exclude_sequence", parameterToString(*r.excludeSequence, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.hydrated != nil {
		localVarQueryParams.Add("hydrated", parameterToString(*r.hydrated, ""))
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadAssemblyPackagePostRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	v1AssemblyDatasetRequest *V1AssemblyDatasetRequest	
	filename *string	
    Headers map[string]string
}

func (r *ApiDownloadAssemblyPackagePostRequest) V1AssemblyDatasetRequest(v1AssemblyDatasetRequest V1AssemblyDatasetRequest) *ApiDownloadAssemblyPackagePostRequest {
	r.v1AssemblyDatasetRequest = &v1AssemblyDatasetRequest
	return r
}
// Output file name.
func (r *ApiDownloadAssemblyPackagePostRequest) Filename(filename string) *ApiDownloadAssemblyPackagePostRequest {
	r.filename = &filename
	return r
}

func (r ApiDownloadAssemblyPackagePostRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DownloadAssemblyPackagePostExecute(r)
}

/*
DownloadAssemblyPackagePost Get a genome dataset by post

The 'GET' version of download is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDownloadAssemblyPackagePostRequest
*/
func (a *GenomeApiService) DownloadAssemblyPackagePost(ctx _context.Context, v1AssemblyDatasetRequest *V1AssemblyDatasetRequest) ApiDownloadAssemblyPackagePostRequest {
	return ApiDownloadAssemblyPackagePostRequest{
		ApiService: a,
		ctx: ctx,
		v1AssemblyDatasetRequest: v1AssemblyDatasetRequest,
	}
}

// Execute executes the request
//  @return *os.File
func (a *GenomeApiService) DownloadAssemblyPackagePostExecute(r ApiDownloadAssemblyPackagePostRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.DownloadAssemblyPackagePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1AssemblyDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1AssemblyDatasetRequest is required and must be specified")
	}

	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1AssemblyDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenomeDownloadSummaryRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	accessions []string	
	chromosomes *[]string	
	excludeSequence *bool	
	includeAnnotationType *[]V1AnnotationForAssemblyType	
    Headers map[string]string
}

// The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome (&#39;Un&#39;). The filter only applies to fasta sequence.
func (r *ApiGenomeDownloadSummaryRequest) Chromosomes(chromosomes []string) *ApiGenomeDownloadSummaryRequest {
	r.chromosomes = &chromosomes
	return r
}
// Set to true to omit the genomic sequence.
func (r *ApiGenomeDownloadSummaryRequest) ExcludeSequence(excludeSequence bool) *ApiGenomeDownloadSummaryRequest {
	r.excludeSequence = &excludeSequence
	return r
}
// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r *ApiGenomeDownloadSummaryRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForAssemblyType) *ApiGenomeDownloadSummaryRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

func (r ApiGenomeDownloadSummaryRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.GenomeDownloadSummaryExecute(r)
}

/*
GenomeDownloadSummary Preview genome dataset download

Get a download summary by accession in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions NCBI genome assembly accessions
 @return ApiGenomeDownloadSummaryRequest
*/
func (a *GenomeApiService) GenomeDownloadSummary(ctx _context.Context, accessions []string) ApiGenomeDownloadSummaryRequest {
	return ApiGenomeDownloadSummaryRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V1DownloadSummary
func (a *GenomeApiService) GenomeDownloadSummaryExecute(r ApiGenomeDownloadSummaryRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDownloadSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/download_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.chromosomes != nil {
		t := *r.chromosomes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("chromosomes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("chromosomes", parameterToString(t, "multi"))
		}
	}
	if r.excludeSequence != nil {
		localVarQueryParams.Add("exclude_sequence", parameterToString(*r.excludeSequence, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenomeDownloadSummaryByPostRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	v1AssemblyDatasetRequest *V1AssemblyDatasetRequest	
    Headers map[string]string
}

func (r *ApiGenomeDownloadSummaryByPostRequest) V1AssemblyDatasetRequest(v1AssemblyDatasetRequest V1AssemblyDatasetRequest) *ApiGenomeDownloadSummaryByPostRequest {
	r.v1AssemblyDatasetRequest = &v1AssemblyDatasetRequest
	return r
}

func (r ApiGenomeDownloadSummaryByPostRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.GenomeDownloadSummaryByPostExecute(r)
}

/*
GenomeDownloadSummaryByPost Preview genome dataset download by POST

The 'GET' version of download summary is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenomeDownloadSummaryByPostRequest
*/
func (a *GenomeApiService) GenomeDownloadSummaryByPost(ctx _context.Context, v1AssemblyDatasetRequest *V1AssemblyDatasetRequest) ApiGenomeDownloadSummaryByPostRequest {
	return ApiGenomeDownloadSummaryByPostRequest{
		ApiService: a,
		ctx: ctx,
		v1AssemblyDatasetRequest: v1AssemblyDatasetRequest,
	}
}

// Execute executes the request
//  @return V1DownloadSummary
func (a *GenomeApiService) GenomeDownloadSummaryByPostExecute(r ApiGenomeDownloadSummaryByPostRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDownloadSummaryByPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/download_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1AssemblyDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1AssemblyDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1AssemblyDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenomeMetadataByPostRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	v1AssemblyMetadataRequest *V1AssemblyMetadataRequest	
    Headers map[string]string
}

func (r *ApiGenomeMetadataByPostRequest) V1AssemblyMetadataRequest(v1AssemblyMetadataRequest V1AssemblyMetadataRequest) *ApiGenomeMetadataByPostRequest {
	r.v1AssemblyMetadataRequest = &v1AssemblyMetadataRequest
	return r
}

func (r ApiGenomeMetadataByPostRequest) Execute() (V1AssemblyMetadata, *_nethttp.Response, error) {
	return r.ApiService.GenomeMetadataByPostExecute(r)
}

/*
GenomeMetadataByPost Get genome metadata by variety of identifiers

Get detailed metadata for assembled genomes.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenomeMetadataByPostRequest
*/
func (a *GenomeApiService) GenomeMetadataByPost(ctx _context.Context, v1AssemblyMetadataRequest *V1AssemblyMetadataRequest) ApiGenomeMetadataByPostRequest {
	return ApiGenomeMetadataByPostRequest{
		ApiService: a,
		ctx: ctx,
		v1AssemblyMetadataRequest: v1AssemblyMetadataRequest,
	}
}

// Execute executes the request
//  @return V1AssemblyMetadata
func (a *GenomeApiService) GenomeMetadataByPostExecute(r ApiGenomeMetadataByPostRequest) (V1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeMetadataByPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1AssemblyMetadataRequest == nil {
		return localVarReturnValue, nil, reportError("v1AssemblyMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1AssemblyMetadataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenomeTaxNameQueryRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	taxonQuery string	
	taxRankFilter *V1OrganismQueryRequestTaxRankFilter	
    Headers map[string]string
}

// Set the scope of searched tax ranks
func (r *ApiGenomeTaxNameQueryRequest) TaxRankFilter(taxRankFilter V1OrganismQueryRequestTaxRankFilter) *ApiGenomeTaxNameQueryRequest {
	r.taxRankFilter = &taxRankFilter
	return r
}

func (r ApiGenomeTaxNameQueryRequest) Execute() (V1SciNameAndIds, *_nethttp.Response, error) {
	return r.ApiService.GenomeTaxNameQueryExecute(r)
}

/*
GenomeTaxNameQuery Get a list of taxonomy names and IDs found in the assembly dataset given a partial taxonomic name

This endpoint retrieves a list of taxonomy names and IDs found in the assembly dataset given a partial taxonomic name of any rank.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxonQuery NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return ApiGenomeTaxNameQueryRequest
*/
func (a *GenomeApiService) GenomeTaxNameQuery(ctx _context.Context, taxonQuery string) ApiGenomeTaxNameQueryRequest {
	return ApiGenomeTaxNameQueryRequest{
		ApiService: a,
		ctx: ctx,
		taxonQuery: taxonQuery,
	}
}

// Execute executes the request
//  @return V1SciNameAndIds
func (a *GenomeApiService) GenomeTaxNameQueryExecute(r ApiGenomeTaxNameQueryRequest) (V1SciNameAndIds, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1SciNameAndIds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeTaxNameQuery")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/taxon_suggest/{taxon_query}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon_query"+"}", _neturl.PathEscape(parameterToString(r.taxonQuery, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.taxRankFilter != nil {
		localVarQueryParams.Add("tax_rank_filter", parameterToString(*r.taxRankFilter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenomeTaxTreeRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	taxon string	
	childrenOnly *bool	
    Headers map[string]string
}

// Only report the children of the requested taxon and not their descendants
func (r *ApiGenomeTaxTreeRequest) ChildrenOnly(childrenOnly bool) *ApiGenomeTaxTreeRequest {
	r.childrenOnly = &childrenOnly
	return r
}

func (r ApiGenomeTaxTreeRequest) Execute() (V1Organism, *_nethttp.Response, error) {
	return r.ApiService.GenomeTaxTreeExecute(r)
}

/*
GenomeTaxTree Get a taxonomic subtree by taxonomic identifier

Using a NCBI Taxonomy ID or name (common or scientific) at any rank, get a subtree filtered for species with assembled genomes.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return ApiGenomeTaxTreeRequest
*/
func (a *GenomeApiService) GenomeTaxTree(ctx _context.Context, taxon string) ApiGenomeTaxTreeRequest {
	return ApiGenomeTaxTreeRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V1Organism
func (a *GenomeApiService) GenomeTaxTreeExecute(r ApiGenomeTaxTreeRequest) (V1Organism, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1Organism
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeTaxTree")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/taxon/{taxon}/tree"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.childrenOnly != nil {
		localVarQueryParams.Add("children_only", parameterToString(*r.childrenOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
