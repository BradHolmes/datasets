/*
 * NCBI Datasets API
 *
 * NCBI service to query and download biological sequence data across all domains of life from NCBI databases.
 *
 * API version: v1alpha
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package datasets

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
	"reflect"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// GenomeApiService GenomeApi service
type GenomeApiService service

// AssemblyDescriptorsByAccessionsOpts Optional parameters for the method 'AssemblyDescriptorsByAccessions'
type AssemblyDescriptorsByAccessionsOpts struct {
    FiltersReferenceOnly optional.Bool
    FiltersAssemblySource optional.String
    FiltersHasAnnotation optional.Bool
    FiltersAssemblyLevel optional.Interface
    FiltersFirstReleaseDate optional.Time
    FiltersLastReleaseDate optional.Time
    FiltersSearchText optional.Interface
    PageSize optional.Int32
    PageToken optional.String
}

/*
AssemblyDescriptorsByAccessions Get genome metadata by accession
Get detailed metadata for assembled genomes by accession in a JSON output format.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accessions
 * @param optional nil or *AssemblyDescriptorsByAccessionsOpts - Optional Parameters:
 * @param "FiltersReferenceOnly" (optional.Bool) -  If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
 * @param "FiltersAssemblySource" (optional.String) -  Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies.
 * @param "FiltersHasAnnotation" (optional.Bool) -  Return only annotated genome assemblies.
 * @param "FiltersAssemblyLevel" (optional.Interface of []string) -  Only return genome assemblies that have one of the specified assembly levels.
 * @param "FiltersFirstReleaseDate" (optional.Time) -  Only return genome assemblies that were released on or after the specified date.
 * @param "FiltersLastReleaseDate" (optional.Time) -  Only return genome assemblies that were released on or before to the specified date.
 * @param "FiltersSearchText" (optional.Interface of []string) -  Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields.
 * @param "PageSize" (optional.Int32) -  The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size,  `page_token` can be used to retrieve the remaining results.
 * @param "PageToken" (optional.String) -  A page token is returned from an `AssemblyMetadataRequest` call with more than `page_size` results. Use this token, along with the previous  `AssemblyMetadataRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
@return V1alpha1AssemblyMetadata
*/
func (a *GenomeApiService) AssemblyDescriptorsByAccessions(ctx _context.Context, accessions []string, localVarOptionals *AssemblyDescriptorsByAccessionsOpts) (V1alpha1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1alpha1AssemblyMetadata
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/accession/{accessions}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(accessions, "csv")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if len(accessions) < 1 {
		return localVarReturnValue, nil, reportError("accessions must have at least 1 elements")
	}

	if localVarOptionals != nil && localVarOptionals.FiltersReferenceOnly.IsSet() {
		localVarQueryParams.Add("filters.reference_only", parameterToString(localVarOptionals.FiltersReferenceOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersAssemblySource.IsSet() {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(localVarOptionals.FiltersAssemblySource.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersHasAnnotation.IsSet() {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(localVarOptionals.FiltersHasAnnotation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersAssemblyLevel.IsSet() {
		t:=localVarOptionals.FiltersAssemblyLevel.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.FiltersFirstReleaseDate.IsSet() {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(localVarOptionals.FiltersFirstReleaseDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersLastReleaseDate.IsSet() {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(localVarOptionals.FiltersLastReleaseDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSearchText.IsSet() {
		t:=localVarOptionals.FiltersSearchText.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageToken.IsSet() {
		localVarQueryParams.Add("page_token", parameterToString(localVarOptionals.PageToken.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AssemblyDescriptorsByBioprojectOpts Optional parameters for the method 'AssemblyDescriptorsByBioproject'
type AssemblyDescriptorsByBioprojectOpts struct {
    FiltersReferenceOnly optional.Bool
    FiltersAssemblySource optional.String
    FiltersHasAnnotation optional.Bool
    FiltersAssemblyLevel optional.Interface
    FiltersFirstReleaseDate optional.Time
    FiltersLastReleaseDate optional.Time
    FiltersSearchText optional.Interface
    ReturnedContent optional.String
    PageSize optional.Int32
    PageToken optional.String
}

/*
AssemblyDescriptorsByBioproject Get genome metadata by bioproject accession
Get detailed metadata for assembled genomes by bioproject accession in a JSON output format.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accessions
 * @param optional nil or *AssemblyDescriptorsByBioprojectOpts - Optional Parameters:
 * @param "FiltersReferenceOnly" (optional.Bool) -  If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
 * @param "FiltersAssemblySource" (optional.String) -  Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies.
 * @param "FiltersHasAnnotation" (optional.Bool) -  Return only annotated genome assemblies.
 * @param "FiltersAssemblyLevel" (optional.Interface of []string) -  Only return genome assemblies that have one of the specified assembly levels.
 * @param "FiltersFirstReleaseDate" (optional.Time) -  Only return genome assemblies that were released on or after the specified date.
 * @param "FiltersLastReleaseDate" (optional.Time) -  Only return genome assemblies that were released on or before to the specified date.
 * @param "FiltersSearchText" (optional.Interface of []string) -  Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields.
 * @param "ReturnedContent" (optional.String) -  Return either assembly accessions, or entire assembly-metadata records.
 * @param "PageSize" (optional.Int32) -  The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size,  `page_token` can be used to retrieve the remaining results.
 * @param "PageToken" (optional.String) -  A page token is returned from an `AssemblyMetadataRequest` call with more than `page_size` results. Use this token, along with the previous  `AssemblyMetadataRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
@return V1alpha1AssemblyMetadata
*/
func (a *GenomeApiService) AssemblyDescriptorsByBioproject(ctx _context.Context, accessions []string, localVarOptionals *AssemblyDescriptorsByBioprojectOpts) (V1alpha1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1alpha1AssemblyMetadata
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/bioproject/{accessions}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(accessions, "csv")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if len(accessions) < 1 {
		return localVarReturnValue, nil, reportError("accessions must have at least 1 elements")
	}

	if localVarOptionals != nil && localVarOptionals.FiltersReferenceOnly.IsSet() {
		localVarQueryParams.Add("filters.reference_only", parameterToString(localVarOptionals.FiltersReferenceOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersAssemblySource.IsSet() {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(localVarOptionals.FiltersAssemblySource.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersHasAnnotation.IsSet() {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(localVarOptionals.FiltersHasAnnotation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersAssemblyLevel.IsSet() {
		t:=localVarOptionals.FiltersAssemblyLevel.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.FiltersFirstReleaseDate.IsSet() {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(localVarOptionals.FiltersFirstReleaseDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersLastReleaseDate.IsSet() {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(localVarOptionals.FiltersLastReleaseDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSearchText.IsSet() {
		t:=localVarOptionals.FiltersSearchText.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ReturnedContent.IsSet() {
		localVarQueryParams.Add("returned_content", parameterToString(localVarOptionals.ReturnedContent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageToken.IsSet() {
		localVarQueryParams.Add("page_token", parameterToString(localVarOptionals.PageToken.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AssemblyDescriptorsByTaxonOpts Optional parameters for the method 'AssemblyDescriptorsByTaxon'
type AssemblyDescriptorsByTaxonOpts struct {
    FiltersReferenceOnly optional.Bool
    FiltersAssemblySource optional.String
    FiltersHasAnnotation optional.Bool
    FiltersAssemblyLevel optional.Interface
    FiltersFirstReleaseDate optional.Time
    FiltersLastReleaseDate optional.Time
    FiltersSearchText optional.Interface
    TaxExactMatch optional.Bool
    ReturnedContent optional.String
    PageSize optional.Int32
    PageToken optional.String
}

/*
AssemblyDescriptorsByTaxon Get genome metadata by taxonomic identifier
Get detailed metadata on all assembled genomes for a specified NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 * @param optional nil or *AssemblyDescriptorsByTaxonOpts - Optional Parameters:
 * @param "FiltersReferenceOnly" (optional.Bool) -  If true, only return reference and representative (GCF_ and GCA_) genome assemblies.
 * @param "FiltersAssemblySource" (optional.String) -  Return only RefSeq (GCF_) or GenBank (GCA_) genome assemblies.
 * @param "FiltersHasAnnotation" (optional.Bool) -  Return only annotated genome assemblies.
 * @param "FiltersAssemblyLevel" (optional.Interface of []string) -  Only return genome assemblies that have one of the specified assembly levels.
 * @param "FiltersFirstReleaseDate" (optional.Time) -  Only return genome assemblies that were released on or after the specified date.
 * @param "FiltersLastReleaseDate" (optional.Time) -  Only return genome assemblies that were released on or before to the specified date.
 * @param "FiltersSearchText" (optional.Interface of []string) -  Only return results whose fields contain the specified search terms in their taxon, infraspecific, assembly name or submitter fields.
 * @param "TaxExactMatch" (optional.Bool) -  If true, only return assemblies with the given NCBI Taxonomy ID, or name. Otherwise, assemblies from taxonomy subtree are included, too. Ignored for assembly_accession request.
 * @param "ReturnedContent" (optional.String) -  Return either assembly accessions, or entire assembly-metadata records.
 * @param "PageSize" (optional.Int32) -  The maximum number of genome assemblies to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size,  `page_token` can be used to retrieve the remaining results.
 * @param "PageToken" (optional.String) -  A page token is returned from an `AssemblyMetadataRequest` call with more than `page_size` results. Use this token, along with the previous  `AssemblyMetadataRequest` parameters, to retrieve the next page of results. When `page_token` is empty, all results have been retrieved.
@return V1alpha1AssemblyMetadata
*/
func (a *GenomeApiService) AssemblyDescriptorsByTaxon(ctx _context.Context, taxon string, localVarOptionals *AssemblyDescriptorsByTaxonOpts) (V1alpha1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1alpha1AssemblyMetadata
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/taxon/{taxon}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(taxon, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.FiltersReferenceOnly.IsSet() {
		localVarQueryParams.Add("filters.reference_only", parameterToString(localVarOptionals.FiltersReferenceOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersAssemblySource.IsSet() {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(localVarOptionals.FiltersAssemblySource.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersHasAnnotation.IsSet() {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(localVarOptionals.FiltersHasAnnotation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersAssemblyLevel.IsSet() {
		t:=localVarOptionals.FiltersAssemblyLevel.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.FiltersFirstReleaseDate.IsSet() {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(localVarOptionals.FiltersFirstReleaseDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersLastReleaseDate.IsSet() {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(localVarOptionals.FiltersLastReleaseDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSearchText.IsSet() {
		t:=localVarOptionals.FiltersSearchText.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.TaxExactMatch.IsSet() {
		localVarQueryParams.Add("tax_exact_match", parameterToString(localVarOptionals.TaxExactMatch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnedContent.IsSet() {
		localVarQueryParams.Add("returned_content", parameterToString(localVarOptionals.ReturnedContent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageSize.IsSet() {
		localVarQueryParams.Add("page_size", parameterToString(localVarOptionals.PageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PageToken.IsSet() {
		localVarQueryParams.Add("page_token", parameterToString(localVarOptionals.PageToken.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
CheckAssemblyAvailability Check the validity of genome accessions
The &#39;GET&#39; version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accessions NCBI genome assembly accessions
@return V1alpha1AssemblyDatasetAvailability
*/
func (a *GenomeApiService) CheckAssemblyAvailability(ctx _context.Context, accessions []string) (V1alpha1AssemblyDatasetAvailability, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1alpha1AssemblyDatasetAvailability
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/accession/{accessions}/check"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(accessions, "csv")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if len(accessions) < 1 {
		return localVarReturnValue, nil, reportError("accessions must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
CheckAssemblyAvailabilityPost Check the validity of many genome accessions in a single request
The &#39;GET&#39; version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
@return V1alpha1AssemblyDatasetAvailability
*/
func (a *GenomeApiService) CheckAssemblyAvailabilityPost(ctx _context.Context, body V1alpha1AssemblyDatasetRequest) (V1alpha1AssemblyDatasetAvailability, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1alpha1AssemblyDatasetAvailability
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/check"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// DownloadAssemblyPackageOpts Optional parameters for the method 'DownloadAssemblyPackage'
type DownloadAssemblyPackageOpts struct {
    Chromosomes optional.Interface
    ExcludeSequence optional.Bool
    IncludeAnnotationType optional.Interface
    Hydrated optional.String
    Filename optional.String
}

/*
DownloadAssemblyPackage Get a genome dataset by accession
Download a genome dataset including fasta sequence, annotation and a detailed data report by accession.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accessions NCBI genome assembly accessions
 * @param optional nil or *DownloadAssemblyPackageOpts - Optional Parameters:
 * @param "Chromosomes" (optional.Interface of []string) -  The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.
 * @param "ExcludeSequence" (optional.Bool) -  Set to true to omit the genomic sequence.
 * @param "IncludeAnnotationType" (optional.Interface of []string) -  Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
 * @param "Hydrated" (optional.String) -  Set to DATA_REPORT_ONLY, to only retrieve data-reports.
 * @param "Filename" (optional.String) -  Output file name.
@return *os.File
*/
func (a *GenomeApiService) DownloadAssemblyPackage(ctx _context.Context, accessions []string, localVarOptionals *DownloadAssemblyPackageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/accession/{accessions}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(accessions, "csv")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if len(accessions) < 1 {
		return localVarReturnValue, nil, reportError("accessions must have at least 1 elements")
	}

	if localVarOptionals != nil && localVarOptionals.Chromosomes.IsSet() {
		t:=localVarOptionals.Chromosomes.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("chromosomes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("chromosomes", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeSequence.IsSet() {
		localVarQueryParams.Add("exclude_sequence", parameterToString(localVarOptionals.ExcludeSequence.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeAnnotationType.IsSet() {
		t:=localVarOptionals.IncludeAnnotationType.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.Hydrated.IsSet() {
		localVarQueryParams.Add("hydrated", parameterToString(localVarOptionals.Hydrated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filename.IsSet() {
		localVarQueryParams.Add("filename", parameterToString(localVarOptionals.Filename.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// DownloadAssemblyPackagePostOpts Optional parameters for the method 'DownloadAssemblyPackagePost'
type DownloadAssemblyPackagePostOpts struct {
    Filename optional.String
}

/*
DownloadAssemblyPackagePost Get a genome dataset by post
The &#39;GET&#39; version of download is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
 * @param optional nil or *DownloadAssemblyPackagePostOpts - Optional Parameters:
 * @param "Filename" (optional.String) -  Output file name.
@return *os.File
*/
func (a *GenomeApiService) DownloadAssemblyPackagePost(ctx _context.Context, body V1alpha1AssemblyDatasetRequest, localVarOptionals *DownloadAssemblyPackagePostOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/download"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Filename.IsSet() {
		localVarQueryParams.Add("filename", parameterToString(localVarOptionals.Filename.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GenomeDownloadSummaryOpts Optional parameters for the method 'GenomeDownloadSummary'
type GenomeDownloadSummaryOpts struct {
    Chromosomes optional.Interface
    ExcludeSequence optional.Bool
    IncludeAnnotationType optional.Interface
}

/*
GenomeDownloadSummary Preview genome dataset download
Get a download summary by accession in a JSON output format.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accessions NCBI genome assembly accessions
 * @param optional nil or *GenomeDownloadSummaryOpts - Optional Parameters:
 * @param "Chromosomes" (optional.Interface of []string) -  The default setting is all chromosome. Specify individual chromosome by string (1,2,MT or chr1,chr2.chrMT). Unplaced sequences are treated like their own chromosome ('Un'). The filter only applies to fasta sequence.
 * @param "ExcludeSequence" (optional.Bool) -  Set to true to omit the genomic sequence.
 * @param "IncludeAnnotationType" (optional.Interface of []string) -  Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
@return V1alpha1DownloadSummary
*/
func (a *GenomeApiService) GenomeDownloadSummary(ctx _context.Context, accessions []string, localVarOptionals *GenomeDownloadSummaryOpts) (V1alpha1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1alpha1DownloadSummary
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/accession/{accessions}/download_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(accessions, "csv")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if len(accessions) < 1 {
		return localVarReturnValue, nil, reportError("accessions must have at least 1 elements")
	}

	if localVarOptionals != nil && localVarOptionals.Chromosomes.IsSet() {
		t:=localVarOptionals.Chromosomes.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("chromosomes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("chromosomes", parameterToString(t, "multi"))
		}
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeSequence.IsSet() {
		localVarQueryParams.Add("exclude_sequence", parameterToString(localVarOptionals.ExcludeSequence.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeAnnotationType.IsSet() {
		t:=localVarOptionals.IncludeAnnotationType.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GenomeDownloadSummaryByPost Preview genome dataset download by POST
The &#39;GET&#39; version of download summary is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
@return V1alpha1DownloadSummary
*/
func (a *GenomeApiService) GenomeDownloadSummaryByPost(ctx _context.Context, body V1alpha1AssemblyDatasetRequest) (V1alpha1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1alpha1DownloadSummary
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/download_summary"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GenomeMetadataByPost Get genome metadata by accession
Get detailed metadata for assembled genomes by accession in a JSON output format.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body
@return V1alpha1AssemblyMetadata
*/
func (a *GenomeApiService) GenomeMetadataByPost(ctx _context.Context, body V1alpha1AssemblyMetadataRequest) (V1alpha1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1alpha1AssemblyMetadata
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GenomeTaxNameQuery Get a list of taxonomy names and IDs found in the assembly dataset given a partial taxonomic name.
This endpoint retrieves a list of taxonomy names and IDs found in the assembly dataset given a partial taxonomic name of any rank.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taxonQuery NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
@return V1alpha1SciNameAndIds
*/
func (a *GenomeApiService) GenomeTaxNameQuery(ctx _context.Context, taxonQuery string) (V1alpha1SciNameAndIds, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1alpha1SciNameAndIds
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/taxon_suggest/{taxon_query}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon_query"+"}", _neturl.PathEscape(parameterToString(taxonQuery, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GenomeTaxTree Get a taxonomic subtree by taxonomic identifier
Using a NCBI Taxonomy ID or name (common or scientific) at any rank, get a subtree filtered for species with assembled genomes
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
@return V1alpha1Organism
*/
func (a *GenomeApiService) GenomeTaxTree(ctx _context.Context, taxon string) (V1alpha1Organism, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1alpha1Organism
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/genome/taxon/{taxon}/tree"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(taxon, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarHTTPHeaderAccept == "application/zip" {
		localVarHeaderParams["Accept-encoding"] = "identity"
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["api-key"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
