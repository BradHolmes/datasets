/*
 * NCBI Datasets API
 *
 * ### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated bag](https://www.ncbi.nlm.nih.gov/datasets/docs/rehydrate/), and retrieve the individual data files at a later time. 
 *
 * API version: v1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package datasets

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
	"time"
	"os"
)

// Linger please
var (
	_ _context.Context
)

// GenomeApiService GenomeApi service
type GenomeApiService service

type ApiAssemblyDescriptorsByAccessionsRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	accessions []string
	filtersReferenceOnly *bool
	filtersAssemblySource *V1AssemblyDatasetDescriptorsFilterAssemblySource
	filtersHasAnnotation *bool
	filtersAssemblyLevel *[]V1AssemblyDatasetDescriptorsFilterAssemblyLevel
	filtersFirstReleaseDate *time.Time
	filtersLastReleaseDate *time.Time
	filtersSearchText *[]string
	pageSize *int32
	pageToken *string
}

func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersReferenceOnly(filtersReferenceOnly bool) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersAssemblySource(filtersAssemblySource V1AssemblyDatasetDescriptorsFilterAssemblySource) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersHasAnnotation(filtersHasAnnotation bool) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V1AssemblyDatasetDescriptorsFilterAssemblyLevel) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}
func (r *ApiAssemblyDescriptorsByAccessionsRequest) FiltersSearchText(filtersSearchText []string) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}
func (r *ApiAssemblyDescriptorsByAccessionsRequest) PageSize(pageSize int32) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.pageSize = &pageSize
	return r
}
func (r *ApiAssemblyDescriptorsByAccessionsRequest) PageToken(pageToken string) *ApiAssemblyDescriptorsByAccessionsRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiAssemblyDescriptorsByAccessionsRequest) Execute() (V1AssemblyMetadata, *_nethttp.Response, error) {
	return r.ApiService.AssemblyDescriptorsByAccessionsExecute(r)
}

/*
 * AssemblyDescriptorsByAccessions Get genome metadata by accession
 * Get detailed metadata for assembled genomes by accession in a JSON output format.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accessions
 * @return ApiAssemblyDescriptorsByAccessionsRequest
 */
func (a *GenomeApiService) AssemblyDescriptorsByAccessions(ctx _context.Context, accessions []string) ApiAssemblyDescriptorsByAccessionsRequest {
	return ApiAssemblyDescriptorsByAccessionsRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

/*
 * Execute executes the request
 * @return V1AssemblyMetadata
 */
func (a *GenomeApiService) AssemblyDescriptorsByAccessionsExecute(r ApiAssemblyDescriptorsByAccessionsRequest) (V1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AssemblyDescriptorsByAccessions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssemblyDescriptorsByBioprojectRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	accessions []string
	filtersReferenceOnly *bool
	filtersAssemblySource *V1AssemblyDatasetDescriptorsFilterAssemblySource
	filtersHasAnnotation *bool
	filtersAssemblyLevel *[]V1AssemblyDatasetDescriptorsFilterAssemblyLevel
	filtersFirstReleaseDate *time.Time
	filtersLastReleaseDate *time.Time
	filtersSearchText *[]string
	returnedContent *V1AssemblyMetadataRequestContentType
	pageSize *int32
	pageToken *string
}

func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersReferenceOnly(filtersReferenceOnly bool) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersAssemblySource(filtersAssemblySource V1AssemblyDatasetDescriptorsFilterAssemblySource) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersHasAnnotation(filtersHasAnnotation bool) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V1AssemblyDatasetDescriptorsFilterAssemblyLevel) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}
func (r *ApiAssemblyDescriptorsByBioprojectRequest) FiltersSearchText(filtersSearchText []string) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}
func (r *ApiAssemblyDescriptorsByBioprojectRequest) ReturnedContent(returnedContent V1AssemblyMetadataRequestContentType) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.returnedContent = &returnedContent
	return r
}
func (r *ApiAssemblyDescriptorsByBioprojectRequest) PageSize(pageSize int32) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.pageSize = &pageSize
	return r
}
func (r *ApiAssemblyDescriptorsByBioprojectRequest) PageToken(pageToken string) *ApiAssemblyDescriptorsByBioprojectRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiAssemblyDescriptorsByBioprojectRequest) Execute() (V1AssemblyMetadata, *_nethttp.Response, error) {
	return r.ApiService.AssemblyDescriptorsByBioprojectExecute(r)
}

/*
 * AssemblyDescriptorsByBioproject Get genome metadata by bioproject accession
 * Get detailed metadata for assembled genomes by bioproject accession in a JSON output format.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accessions
 * @return ApiAssemblyDescriptorsByBioprojectRequest
 */
func (a *GenomeApiService) AssemblyDescriptorsByBioproject(ctx _context.Context, accessions []string) ApiAssemblyDescriptorsByBioprojectRequest {
	return ApiAssemblyDescriptorsByBioprojectRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

/*
 * Execute executes the request
 * @return V1AssemblyMetadata
 */
func (a *GenomeApiService) AssemblyDescriptorsByBioprojectExecute(r ApiAssemblyDescriptorsByBioprojectRequest) (V1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AssemblyDescriptorsByBioproject")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/bioproject/{accessions}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssemblyDescriptorsByTaxonRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	taxon string
	filtersReferenceOnly *bool
	filtersAssemblySource *V1AssemblyDatasetDescriptorsFilterAssemblySource
	filtersHasAnnotation *bool
	filtersAssemblyLevel *[]V1AssemblyDatasetDescriptorsFilterAssemblyLevel
	filtersFirstReleaseDate *time.Time
	filtersLastReleaseDate *time.Time
	filtersSearchText *[]string
	taxExactMatch *bool
	returnedContent *V1AssemblyMetadataRequestContentType
	pageSize *int32
	pageToken *string
}

func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersReferenceOnly(filtersReferenceOnly bool) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersReferenceOnly = &filtersReferenceOnly
	return r
}
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersAssemblySource(filtersAssemblySource V1AssemblyDatasetDescriptorsFilterAssemblySource) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersAssemblySource = &filtersAssemblySource
	return r
}
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersHasAnnotation(filtersHasAnnotation bool) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersHasAnnotation = &filtersHasAnnotation
	return r
}
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersAssemblyLevel(filtersAssemblyLevel []V1AssemblyDatasetDescriptorsFilterAssemblyLevel) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersAssemblyLevel = &filtersAssemblyLevel
	return r
}
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersFirstReleaseDate(filtersFirstReleaseDate time.Time) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersFirstReleaseDate = &filtersFirstReleaseDate
	return r
}
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersLastReleaseDate(filtersLastReleaseDate time.Time) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersLastReleaseDate = &filtersLastReleaseDate
	return r
}
func (r *ApiAssemblyDescriptorsByTaxonRequest) FiltersSearchText(filtersSearchText []string) *ApiAssemblyDescriptorsByTaxonRequest {
	r.filtersSearchText = &filtersSearchText
	return r
}
func (r *ApiAssemblyDescriptorsByTaxonRequest) TaxExactMatch(taxExactMatch bool) *ApiAssemblyDescriptorsByTaxonRequest {
	r.taxExactMatch = &taxExactMatch
	return r
}
func (r *ApiAssemblyDescriptorsByTaxonRequest) ReturnedContent(returnedContent V1AssemblyMetadataRequestContentType) *ApiAssemblyDescriptorsByTaxonRequest {
	r.returnedContent = &returnedContent
	return r
}
func (r *ApiAssemblyDescriptorsByTaxonRequest) PageSize(pageSize int32) *ApiAssemblyDescriptorsByTaxonRequest {
	r.pageSize = &pageSize
	return r
}
func (r *ApiAssemblyDescriptorsByTaxonRequest) PageToken(pageToken string) *ApiAssemblyDescriptorsByTaxonRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiAssemblyDescriptorsByTaxonRequest) Execute() (V1AssemblyMetadata, *_nethttp.Response, error) {
	return r.ApiService.AssemblyDescriptorsByTaxonExecute(r)
}

/*
 * AssemblyDescriptorsByTaxon Get genome metadata by taxonomic identifier
 * Get detailed metadata on all assembled genomes for a specified NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 * @return ApiAssemblyDescriptorsByTaxonRequest
 */
func (a *GenomeApiService) AssemblyDescriptorsByTaxon(ctx _context.Context, taxon string) ApiAssemblyDescriptorsByTaxonRequest {
	return ApiAssemblyDescriptorsByTaxonRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

/*
 * Execute executes the request
 * @return V1AssemblyMetadata
 */
func (a *GenomeApiService) AssemblyDescriptorsByTaxonExecute(r ApiAssemblyDescriptorsByTaxonRequest) (V1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.AssemblyDescriptorsByTaxon")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/taxon/{taxon}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filtersReferenceOnly != nil {
		localVarQueryParams.Add("filters.reference_only", parameterToString(*r.filtersReferenceOnly, ""))
	}
	if r.filtersAssemblySource != nil {
		localVarQueryParams.Add("filters.assembly_source", parameterToString(*r.filtersAssemblySource, ""))
	}
	if r.filtersHasAnnotation != nil {
		localVarQueryParams.Add("filters.has_annotation", parameterToString(*r.filtersHasAnnotation, ""))
	}
	if r.filtersAssemblyLevel != nil {
		t := *r.filtersAssemblyLevel
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.assembly_level", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.assembly_level", parameterToString(t, "multi"))
		}
	}
	if r.filtersFirstReleaseDate != nil {
		localVarQueryParams.Add("filters.first_release_date", parameterToString(*r.filtersFirstReleaseDate, ""))
	}
	if r.filtersLastReleaseDate != nil {
		localVarQueryParams.Add("filters.last_release_date", parameterToString(*r.filtersLastReleaseDate, ""))
	}
	if r.filtersSearchText != nil {
		t := *r.filtersSearchText
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("filters.search_text", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("filters.search_text", parameterToString(t, "multi"))
		}
	}
	if r.taxExactMatch != nil {
		localVarQueryParams.Add("tax_exact_match", parameterToString(*r.taxExactMatch, ""))
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckAssemblyAvailabilityRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	accessions []string
}


func (r ApiCheckAssemblyAvailabilityRequest) Execute() (V1AssemblyDatasetAvailability, *_nethttp.Response, error) {
	return r.ApiService.CheckAssemblyAvailabilityExecute(r)
}

/*
 * CheckAssemblyAvailability Check the validity of genome accessions
 * The 'GET' version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accessions NCBI genome assembly accessions
 * @return ApiCheckAssemblyAvailabilityRequest
 */
func (a *GenomeApiService) CheckAssemblyAvailability(ctx _context.Context, accessions []string) ApiCheckAssemblyAvailabilityRequest {
	return ApiCheckAssemblyAvailabilityRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

/*
 * Execute executes the request
 * @return V1AssemblyDatasetAvailability
 */
func (a *GenomeApiService) CheckAssemblyAvailabilityExecute(r ApiCheckAssemblyAvailabilityRequest) (V1AssemblyDatasetAvailability, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyDatasetAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.CheckAssemblyAvailability")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/check"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckAssemblyAvailabilityPostRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	v1AssemblyDatasetRequest *V1AssemblyDatasetRequest
}

func (r *ApiCheckAssemblyAvailabilityPostRequest) V1AssemblyDatasetRequest(v1AssemblyDatasetRequest V1AssemblyDatasetRequest) *ApiCheckAssemblyAvailabilityPostRequest {
	r.v1AssemblyDatasetRequest = &v1AssemblyDatasetRequest
	return r
}

func (r ApiCheckAssemblyAvailabilityPostRequest) Execute() (V1AssemblyDatasetAvailability, *_nethttp.Response, error) {
	return r.ApiService.CheckAssemblyAvailabilityPostExecute(r)
}

/*
 * CheckAssemblyAvailabilityPost Check the validity of many genome accessions in a single request
 * The 'GET' version of check is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCheckAssemblyAvailabilityPostRequest
 */
func (a *GenomeApiService) CheckAssemblyAvailabilityPost(ctx _context.Context, v1AssemblyDatasetRequest *V1AssemblyDatasetRequest) ApiCheckAssemblyAvailabilityPostRequest {
	return ApiCheckAssemblyAvailabilityPostRequest{
		ApiService: a,
		ctx: ctx,
		v1AssemblyDatasetRequest: v1AssemblyDatasetRequest,
	}
}

/*
 * Execute executes the request
 * @return V1AssemblyDatasetAvailability
 */
func (a *GenomeApiService) CheckAssemblyAvailabilityPostExecute(r ApiCheckAssemblyAvailabilityPostRequest) (V1AssemblyDatasetAvailability, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyDatasetAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.CheckAssemblyAvailabilityPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/check"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1AssemblyDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1AssemblyDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1AssemblyDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadAssemblyPackageRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	accessions []string
	chromosomes *[]string
	excludeSequence *bool
	includeAnnotationType *[]V1AnnotationForAssemblyType
	hydrated *V1AssemblyDatasetRequestResolution
	filename *string
}

func (r *ApiDownloadAssemblyPackageRequest) Chromosomes(chromosomes []string) *ApiDownloadAssemblyPackageRequest {
	r.chromosomes = &chromosomes
	return r
}
func (r *ApiDownloadAssemblyPackageRequest) ExcludeSequence(excludeSequence bool) *ApiDownloadAssemblyPackageRequest {
	r.excludeSequence = &excludeSequence
	return r
}
func (r *ApiDownloadAssemblyPackageRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForAssemblyType) *ApiDownloadAssemblyPackageRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}
func (r *ApiDownloadAssemblyPackageRequest) Hydrated(hydrated V1AssemblyDatasetRequestResolution) *ApiDownloadAssemblyPackageRequest {
	r.hydrated = &hydrated
	return r
}
func (r *ApiDownloadAssemblyPackageRequest) Filename(filename string) *ApiDownloadAssemblyPackageRequest {
	r.filename = &filename
	return r
}

func (r ApiDownloadAssemblyPackageRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DownloadAssemblyPackageExecute(r)
}

/*
 * DownloadAssemblyPackage Get a genome dataset by accession
 * Download a genome dataset including fasta sequence, annotation and a detailed data report by accession.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accessions NCBI genome assembly accessions
 * @return ApiDownloadAssemblyPackageRequest
 */
func (a *GenomeApiService) DownloadAssemblyPackage(ctx _context.Context, accessions []string) ApiDownloadAssemblyPackageRequest {
	return ApiDownloadAssemblyPackageRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

/*
 * Execute executes the request
 * @return *os.File
 */
func (a *GenomeApiService) DownloadAssemblyPackageExecute(r ApiDownloadAssemblyPackageRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.DownloadAssemblyPackage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.chromosomes != nil {
		t := *r.chromosomes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("chromosomes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("chromosomes", parameterToString(t, "multi"))
		}
	}
	if r.excludeSequence != nil {
		localVarQueryParams.Add("exclude_sequence", parameterToString(*r.excludeSequence, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.hydrated != nil {
		localVarQueryParams.Add("hydrated", parameterToString(*r.hydrated, ""))
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadAssemblyPackagePostRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	v1AssemblyDatasetRequest *V1AssemblyDatasetRequest
	filename *string
}

func (r *ApiDownloadAssemblyPackagePostRequest) V1AssemblyDatasetRequest(v1AssemblyDatasetRequest V1AssemblyDatasetRequest) *ApiDownloadAssemblyPackagePostRequest {
	r.v1AssemblyDatasetRequest = &v1AssemblyDatasetRequest
	return r
}
func (r *ApiDownloadAssemblyPackagePostRequest) Filename(filename string) *ApiDownloadAssemblyPackagePostRequest {
	r.filename = &filename
	return r
}

func (r ApiDownloadAssemblyPackagePostRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DownloadAssemblyPackagePostExecute(r)
}

/*
 * DownloadAssemblyPackagePost Get a genome dataset by post
 * The 'GET' version of download is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiDownloadAssemblyPackagePostRequest
 */
func (a *GenomeApiService) DownloadAssemblyPackagePost(ctx _context.Context, v1AssemblyDatasetRequest *V1AssemblyDatasetRequest) ApiDownloadAssemblyPackagePostRequest {
	return ApiDownloadAssemblyPackagePostRequest{
		ApiService: a,
		ctx: ctx,
		v1AssemblyDatasetRequest: v1AssemblyDatasetRequest,
	}
}

/*
 * Execute executes the request
 * @return *os.File
 */
func (a *GenomeApiService) DownloadAssemblyPackagePostExecute(r ApiDownloadAssemblyPackagePostRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.DownloadAssemblyPackagePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1AssemblyDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1AssemblyDatasetRequest is required and must be specified")
	}

	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1AssemblyDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenomeDownloadSummaryRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	accessions []string
	chromosomes *[]string
	excludeSequence *bool
	includeAnnotationType *[]V1AnnotationForAssemblyType
}

func (r *ApiGenomeDownloadSummaryRequest) Chromosomes(chromosomes []string) *ApiGenomeDownloadSummaryRequest {
	r.chromosomes = &chromosomes
	return r
}
func (r *ApiGenomeDownloadSummaryRequest) ExcludeSequence(excludeSequence bool) *ApiGenomeDownloadSummaryRequest {
	r.excludeSequence = &excludeSequence
	return r
}
func (r *ApiGenomeDownloadSummaryRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForAssemblyType) *ApiGenomeDownloadSummaryRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

func (r ApiGenomeDownloadSummaryRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.GenomeDownloadSummaryExecute(r)
}

/*
 * GenomeDownloadSummary Preview genome dataset download
 * Get a download summary by accession in a JSON output format.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accessions NCBI genome assembly accessions
 * @return ApiGenomeDownloadSummaryRequest
 */
func (a *GenomeApiService) GenomeDownloadSummary(ctx _context.Context, accessions []string) ApiGenomeDownloadSummaryRequest {
	return ApiGenomeDownloadSummaryRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

/*
 * Execute executes the request
 * @return V1DownloadSummary
 */
func (a *GenomeApiService) GenomeDownloadSummaryExecute(r ApiGenomeDownloadSummaryRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDownloadSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/accession/{accessions}/download_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.chromosomes != nil {
		t := *r.chromosomes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("chromosomes", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("chromosomes", parameterToString(t, "multi"))
		}
	}
	if r.excludeSequence != nil {
		localVarQueryParams.Add("exclude_sequence", parameterToString(*r.excludeSequence, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenomeDownloadSummaryByPostRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	v1AssemblyDatasetRequest *V1AssemblyDatasetRequest
}

func (r *ApiGenomeDownloadSummaryByPostRequest) V1AssemblyDatasetRequest(v1AssemblyDatasetRequest V1AssemblyDatasetRequest) *ApiGenomeDownloadSummaryByPostRequest {
	r.v1AssemblyDatasetRequest = &v1AssemblyDatasetRequest
	return r
}

func (r ApiGenomeDownloadSummaryByPostRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.GenomeDownloadSummaryByPostExecute(r)
}

/*
 * GenomeDownloadSummaryByPost Preview genome dataset download by POST
 * The 'GET' version of download summary is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGenomeDownloadSummaryByPostRequest
 */
func (a *GenomeApiService) GenomeDownloadSummaryByPost(ctx _context.Context, v1AssemblyDatasetRequest *V1AssemblyDatasetRequest) ApiGenomeDownloadSummaryByPostRequest {
	return ApiGenomeDownloadSummaryByPostRequest{
		ApiService: a,
		ctx: ctx,
		v1AssemblyDatasetRequest: v1AssemblyDatasetRequest,
	}
}

/*
 * Execute executes the request
 * @return V1DownloadSummary
 */
func (a *GenomeApiService) GenomeDownloadSummaryByPostExecute(r ApiGenomeDownloadSummaryByPostRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeDownloadSummaryByPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/download_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1AssemblyDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1AssemblyDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1AssemblyDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenomeMetadataByPostRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	v1AssemblyMetadataRequest *V1AssemblyMetadataRequest
}

func (r *ApiGenomeMetadataByPostRequest) V1AssemblyMetadataRequest(v1AssemblyMetadataRequest V1AssemblyMetadataRequest) *ApiGenomeMetadataByPostRequest {
	r.v1AssemblyMetadataRequest = &v1AssemblyMetadataRequest
	return r
}

func (r ApiGenomeMetadataByPostRequest) Execute() (V1AssemblyMetadata, *_nethttp.Response, error) {
	return r.ApiService.GenomeMetadataByPostExecute(r)
}

/*
 * GenomeMetadataByPost Get genome metadata by variety of identifiers
 * Get detailed metadata for assembled genomes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGenomeMetadataByPostRequest
 */
func (a *GenomeApiService) GenomeMetadataByPost(ctx _context.Context, v1AssemblyMetadataRequest *V1AssemblyMetadataRequest) ApiGenomeMetadataByPostRequest {
	return ApiGenomeMetadataByPostRequest{
		ApiService: a,
		ctx: ctx,
		v1AssemblyMetadataRequest: v1AssemblyMetadataRequest,
	}
}

/*
 * Execute executes the request
 * @return V1AssemblyMetadata
 */
func (a *GenomeApiService) GenomeMetadataByPostExecute(r ApiGenomeMetadataByPostRequest) (V1AssemblyMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AssemblyMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeMetadataByPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1AssemblyMetadataRequest == nil {
		return localVarReturnValue, nil, reportError("v1AssemblyMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1AssemblyMetadataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenomeTaxNameQueryRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	taxonQuery string
	taxRankFilter *V1OrganismQueryRequestTaxRankFilter
}

func (r *ApiGenomeTaxNameQueryRequest) TaxRankFilter(taxRankFilter V1OrganismQueryRequestTaxRankFilter) *ApiGenomeTaxNameQueryRequest {
	r.taxRankFilter = &taxRankFilter
	return r
}

func (r ApiGenomeTaxNameQueryRequest) Execute() (V1SciNameAndIds, *_nethttp.Response, error) {
	return r.ApiService.GenomeTaxNameQueryExecute(r)
}

/*
 * GenomeTaxNameQuery Get a list of taxonomy names and IDs found in the assembly dataset given a partial taxonomic name
 * This endpoint retrieves a list of taxonomy names and IDs found in the assembly dataset given a partial taxonomic name of any rank.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taxonQuery NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 * @return ApiGenomeTaxNameQueryRequest
 */
func (a *GenomeApiService) GenomeTaxNameQuery(ctx _context.Context, taxonQuery string) ApiGenomeTaxNameQueryRequest {
	return ApiGenomeTaxNameQueryRequest{
		ApiService: a,
		ctx: ctx,
		taxonQuery: taxonQuery,
	}
}

/*
 * Execute executes the request
 * @return V1SciNameAndIds
 */
func (a *GenomeApiService) GenomeTaxNameQueryExecute(r ApiGenomeTaxNameQueryRequest) (V1SciNameAndIds, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1SciNameAndIds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeTaxNameQuery")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/taxon_suggest/{taxon_query}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon_query"+"}", _neturl.PathEscape(parameterToString(r.taxonQuery, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.taxRankFilter != nil {
		localVarQueryParams.Add("tax_rank_filter", parameterToString(*r.taxRankFilter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenomeTaxTreeRequest struct {
	ctx _context.Context
	ApiService *GenomeApiService
	taxon string
	childrenOnly *bool
}

func (r *ApiGenomeTaxTreeRequest) ChildrenOnly(childrenOnly bool) *ApiGenomeTaxTreeRequest {
	r.childrenOnly = &childrenOnly
	return r
}

func (r ApiGenomeTaxTreeRequest) Execute() (V1Organism, *_nethttp.Response, error) {
	return r.ApiService.GenomeTaxTreeExecute(r)
}

/*
 * GenomeTaxTree Get a taxonomic subtree by taxonomic identifier
 * Using a NCBI Taxonomy ID or name (common or scientific) at any rank, get a subtree filtered for species with assembled genomes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 * @return ApiGenomeTaxTreeRequest
 */
func (a *GenomeApiService) GenomeTaxTree(ctx _context.Context, taxon string) ApiGenomeTaxTreeRequest {
	return ApiGenomeTaxTreeRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

/*
 * Execute executes the request
 * @return V1Organism
 */
func (a *GenomeApiService) GenomeTaxTreeExecute(r ApiGenomeTaxTreeRequest) (V1Organism, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1Organism
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GenomeApiService.GenomeTaxTree")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/genome/taxon/{taxon}/tree"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.childrenOnly != nil {
		localVarQueryParams.Add("children_only", parameterToString(*r.childrenOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
