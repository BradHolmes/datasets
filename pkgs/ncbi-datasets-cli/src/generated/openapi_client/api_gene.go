/*
NCBI Datasets API

### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets version 1 API is considred stable and will not be subject to breaking changes. For some larger downloads, you may want to download a [dehydrated bag](https://www.ncbi.nlm.nih.gov/datasets/docs/v1/how-tos/genomes/large-download/), and retrieve the individual data files at a later time. 

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package datasets

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// GeneApiService GeneApi service
type GeneApiService service

type ApiDownloadGenePackageRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	geneIds []int32	
	includeAnnotationType *[]V1Fasta	
	fastaFilter *[]string	
	filename *string	
    Headers map[string]string
}

// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r *ApiDownloadGenePackageRequest) IncludeAnnotationType(includeAnnotationType []V1Fasta) *ApiDownloadGenePackageRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}
// Limit the FASTA sequences in the datasets package to these transcript and protein accessions
func (r *ApiDownloadGenePackageRequest) FastaFilter(fastaFilter []string) *ApiDownloadGenePackageRequest {
	r.fastaFilter = &fastaFilter
	return r
}
// Output file name.
func (r *ApiDownloadGenePackageRequest) Filename(filename string) *ApiDownloadGenePackageRequest {
	r.filename = &filename
	return r
}

func (r ApiDownloadGenePackageRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DownloadGenePackageExecute(r)
}

/*
DownloadGenePackage Get a gene dataset by gene ID

Get a gene dataset including gene, transcript and protein fasta sequence, annotation and metadata by gene ID.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geneIds NCBI gene ids
 @return ApiDownloadGenePackageRequest
*/
func (a *GeneApiService) DownloadGenePackage(ctx _context.Context, geneIds []int32) ApiDownloadGenePackageRequest {
	return ApiDownloadGenePackageRequest{
		ApiService: a,
		ctx: ctx,
		geneIds: geneIds,
	}
}

// Execute executes the request
//  @return *os.File
func (a *GeneApiService) DownloadGenePackageExecute(r ApiDownloadGenePackageRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.DownloadGenePackage")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/id/{gene_ids}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"gene_ids"+"}", _neturl.PathEscape(parameterToString(r.geneIds, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.fastaFilter != nil {
		t := *r.fastaFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("fasta_filter", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("fasta_filter", parameterToString(t, "multi"))
		}
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadGenePackagePostRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	v1GeneDatasetRequest *V1GeneDatasetRequest	
	filename *string	
    Headers map[string]string
}

func (r *ApiDownloadGenePackagePostRequest) V1GeneDatasetRequest(v1GeneDatasetRequest V1GeneDatasetRequest) *ApiDownloadGenePackagePostRequest {
	r.v1GeneDatasetRequest = &v1GeneDatasetRequest
	return r
}
// Output file name.
func (r *ApiDownloadGenePackagePostRequest) Filename(filename string) *ApiDownloadGenePackagePostRequest {
	r.filename = &filename
	return r
}

func (r ApiDownloadGenePackagePostRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.DownloadGenePackagePostExecute(r)
}

/*
DownloadGenePackagePost Get a gene dataset by POST

Get a gene dataset including gene, transcript and protein fasta sequence, annotation and metadata by POST.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDownloadGenePackagePostRequest
*/
func (a *GeneApiService) DownloadGenePackagePost(ctx _context.Context, v1GeneDatasetRequest *V1GeneDatasetRequest) ApiDownloadGenePackagePostRequest {
	return ApiDownloadGenePackagePostRequest{
		ApiService: a,
		ctx: ctx,
		v1GeneDatasetRequest: v1GeneDatasetRequest,
	}
}

// Execute executes the request
//  @return *os.File
func (a *GeneApiService) DownloadGenePackagePostExecute(r ApiDownloadGenePackagePostRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.DownloadGenePackagePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1GeneDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1GeneDatasetRequest is required and must be specified")
	}

	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1GeneDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneDownloadSummaryByAccessionRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	accessions []string	
	fastaFilter *[]string	
    Headers map[string]string
}

// Limit the FASTA sequences in the datasets package to these transcript and protein accessions
func (r *ApiGeneDownloadSummaryByAccessionRequest) FastaFilter(fastaFilter []string) *ApiGeneDownloadSummaryByAccessionRequest {
	r.fastaFilter = &fastaFilter
	return r
}

func (r ApiGeneDownloadSummaryByAccessionRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.GeneDownloadSummaryByAccessionExecute(r)
}

/*
GeneDownloadSummaryByAccession Get gene download summary by RefSeq Accession

Get gene download summary by RefSeq Accession in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions RNA or Protein accessions.
 @return ApiGeneDownloadSummaryByAccessionRequest
*/
func (a *GeneApiService) GeneDownloadSummaryByAccession(ctx _context.Context, accessions []string) ApiGeneDownloadSummaryByAccessionRequest {
	return ApiGeneDownloadSummaryByAccessionRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V1DownloadSummary
func (a *GeneApiService) GeneDownloadSummaryByAccessionExecute(r ApiGeneDownloadSummaryByAccessionRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneDownloadSummaryByAccession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/accession/{accessions}/download_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fastaFilter != nil {
		t := *r.fastaFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("fasta_filter", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("fasta_filter", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneDownloadSummaryByIdRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	geneIds []int32	
	fastaFilter *[]string	
    Headers map[string]string
}

// Limit the FASTA sequences in the datasets package to these transcript and protein accessions
func (r *ApiGeneDownloadSummaryByIdRequest) FastaFilter(fastaFilter []string) *ApiGeneDownloadSummaryByIdRequest {
	r.fastaFilter = &fastaFilter
	return r
}

func (r ApiGeneDownloadSummaryByIdRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.GeneDownloadSummaryByIdExecute(r)
}

/*
GeneDownloadSummaryById Get gene download summary by GeneID

Get a download summary by GeneID in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geneIds NCBI gene ids
 @return ApiGeneDownloadSummaryByIdRequest
*/
func (a *GeneApiService) GeneDownloadSummaryById(ctx _context.Context, geneIds []int32) ApiGeneDownloadSummaryByIdRequest {
	return ApiGeneDownloadSummaryByIdRequest{
		ApiService: a,
		ctx: ctx,
		geneIds: geneIds,
	}
}

// Execute executes the request
//  @return V1DownloadSummary
func (a *GeneApiService) GeneDownloadSummaryByIdExecute(r ApiGeneDownloadSummaryByIdRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneDownloadSummaryById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/id/{gene_ids}/download_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"gene_ids"+"}", _neturl.PathEscape(parameterToString(r.geneIds, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fastaFilter != nil {
		t := *r.fastaFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("fasta_filter", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("fasta_filter", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneDownloadSummaryByPostRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	v1GeneDatasetRequest *V1GeneDatasetRequest	
    Headers map[string]string
}

func (r *ApiGeneDownloadSummaryByPostRequest) V1GeneDatasetRequest(v1GeneDatasetRequest V1GeneDatasetRequest) *ApiGeneDownloadSummaryByPostRequest {
	r.v1GeneDatasetRequest = &v1GeneDatasetRequest
	return r
}

func (r ApiGeneDownloadSummaryByPostRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.GeneDownloadSummaryByPostExecute(r)
}

/*
GeneDownloadSummaryByPost Get gene download summary

Get gene download summary in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGeneDownloadSummaryByPostRequest
*/
func (a *GeneApiService) GeneDownloadSummaryByPost(ctx _context.Context, v1GeneDatasetRequest *V1GeneDatasetRequest) ApiGeneDownloadSummaryByPostRequest {
	return ApiGeneDownloadSummaryByPostRequest{
		ApiService: a,
		ctx: ctx,
		v1GeneDatasetRequest: v1GeneDatasetRequest,
	}
}

// Execute executes the request
//  @return V1DownloadSummary
func (a *GeneApiService) GeneDownloadSummaryByPostExecute(r ApiGeneDownloadSummaryByPostRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneDownloadSummaryByPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/download_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1GeneDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1GeneDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1GeneDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneDownloadSummaryByTaxAndSymbolRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	symbols []string	
	taxon string	
	fastaFilter *[]string	
    Headers map[string]string
}

// Limit the FASTA sequences in the datasets package to these transcript and protein accessions
func (r *ApiGeneDownloadSummaryByTaxAndSymbolRequest) FastaFilter(fastaFilter []string) *ApiGeneDownloadSummaryByTaxAndSymbolRequest {
	r.fastaFilter = &fastaFilter
	return r
}

func (r ApiGeneDownloadSummaryByTaxAndSymbolRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.GeneDownloadSummaryByTaxAndSymbolExecute(r)
}

/*
GeneDownloadSummaryByTaxAndSymbol Get gene download summary by gene symbol

Get gene download summary by gene symbol in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbols Gene symbol
 @param taxon Taxon for provided gene symbol
 @return ApiGeneDownloadSummaryByTaxAndSymbolRequest
*/
func (a *GeneApiService) GeneDownloadSummaryByTaxAndSymbol(ctx _context.Context, symbols []string, taxon string) ApiGeneDownloadSummaryByTaxAndSymbolRequest {
	return ApiGeneDownloadSummaryByTaxAndSymbolRequest{
		ApiService: a,
		ctx: ctx,
		symbols: symbols,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V1DownloadSummary
func (a *GeneApiService) GeneDownloadSummaryByTaxAndSymbolExecute(r ApiGeneDownloadSummaryByTaxAndSymbolRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneDownloadSummaryByTaxAndSymbol")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/symbol/{symbols}/taxon/{taxon}/download_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"symbols"+"}", _neturl.PathEscape(parameterToString(r.symbols, "csv")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fastaFilter != nil {
		t := *r.fastaFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("fasta_filter", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("fasta_filter", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneMetadataByAccessionRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	accessions []string	
	returnedContent *V1GeneDatasetRequestContentType	
	sortSchemaField *V1GeneDatasetRequestSortField	
	sortSchemaDirection *V1SortDirection	
	limit *string	
    Headers map[string]string
}

// Return either gene-ids, or entire gene metadata
func (r *ApiGeneMetadataByAccessionRequest) ReturnedContent(returnedContent V1GeneDatasetRequestContentType) *ApiGeneMetadataByAccessionRequest {
	r.returnedContent = &returnedContent
	return r
}
// Select a field to sort on.
func (r *ApiGeneMetadataByAccessionRequest) SortSchemaField(sortSchemaField V1GeneDatasetRequestSortField) *ApiGeneMetadataByAccessionRequest {
	r.sortSchemaField = &sortSchemaField
	return r
}
// Select a direction for the sort.
func (r *ApiGeneMetadataByAccessionRequest) SortSchemaDirection(sortSchemaDirection V1SortDirection) *ApiGeneMetadataByAccessionRequest {
	r.sortSchemaDirection = &sortSchemaDirection
	return r
}
// Limit the number of returned results (\&quot;all\&quot;, \&quot;none\&quot;, otherwise an integer value)
func (r *ApiGeneMetadataByAccessionRequest) Limit(limit string) *ApiGeneMetadataByAccessionRequest {
	r.limit = &limit
	return r
}

func (r ApiGeneMetadataByAccessionRequest) Execute() (V1GeneMetadata, *_nethttp.Response, error) {
	return r.ApiService.GeneMetadataByAccessionExecute(r)
}

/*
GeneMetadataByAccession Get gene metadata by RefSeq Accession

Get detailed gene metadata by RefSeq Accession in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions RNA or Protein accessions.
 @return ApiGeneMetadataByAccessionRequest
*/
func (a *GeneApiService) GeneMetadataByAccession(ctx _context.Context, accessions []string) ApiGeneMetadataByAccessionRequest {
	return ApiGeneMetadataByAccessionRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V1GeneMetadata
func (a *GeneApiService) GeneMetadataByAccessionExecute(r ApiGeneMetadataByAccessionRequest) (V1GeneMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1GeneMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneMetadataByAccession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/accession/{accessions}"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.sortSchemaField != nil {
		localVarQueryParams.Add("sort_schema.field", parameterToString(*r.sortSchemaField, ""))
	}
	if r.sortSchemaDirection != nil {
		localVarQueryParams.Add("sort_schema.direction", parameterToString(*r.sortSchemaDirection, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneMetadataByIdRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	geneIds []int32	
	returnedContent *V1GeneDatasetRequestContentType	
	sortSchemaField *V1GeneDatasetRequestSortField	
	sortSchemaDirection *V1SortDirection	
	limit *string	
    Headers map[string]string
}

// Return either gene-ids, or entire gene metadata
func (r *ApiGeneMetadataByIdRequest) ReturnedContent(returnedContent V1GeneDatasetRequestContentType) *ApiGeneMetadataByIdRequest {
	r.returnedContent = &returnedContent
	return r
}
// Select a field to sort on.
func (r *ApiGeneMetadataByIdRequest) SortSchemaField(sortSchemaField V1GeneDatasetRequestSortField) *ApiGeneMetadataByIdRequest {
	r.sortSchemaField = &sortSchemaField
	return r
}
// Select a direction for the sort.
func (r *ApiGeneMetadataByIdRequest) SortSchemaDirection(sortSchemaDirection V1SortDirection) *ApiGeneMetadataByIdRequest {
	r.sortSchemaDirection = &sortSchemaDirection
	return r
}
// Limit the number of returned results (\&quot;all\&quot;, \&quot;none\&quot;, otherwise an integer value)
func (r *ApiGeneMetadataByIdRequest) Limit(limit string) *ApiGeneMetadataByIdRequest {
	r.limit = &limit
	return r
}

func (r ApiGeneMetadataByIdRequest) Execute() (V1GeneMetadata, *_nethttp.Response, error) {
	return r.ApiService.GeneMetadataByIdExecute(r)
}

/*
GeneMetadataById Get gene metadata by GeneID

Get detailed gene metadata by GeneID in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geneIds NCBI gene ids
 @return ApiGeneMetadataByIdRequest
*/
func (a *GeneApiService) GeneMetadataById(ctx _context.Context, geneIds []int32) ApiGeneMetadataByIdRequest {
	return ApiGeneMetadataByIdRequest{
		ApiService: a,
		ctx: ctx,
		geneIds: geneIds,
	}
}

// Execute executes the request
//  @return V1GeneMetadata
func (a *GeneApiService) GeneMetadataByIdExecute(r ApiGeneMetadataByIdRequest) (V1GeneMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1GeneMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneMetadataById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/id/{gene_ids}"
	localVarPath = strings.Replace(localVarPath, "{"+"gene_ids"+"}", _neturl.PathEscape(parameterToString(r.geneIds, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.sortSchemaField != nil {
		localVarQueryParams.Add("sort_schema.field", parameterToString(*r.sortSchemaField, ""))
	}
	if r.sortSchemaDirection != nil {
		localVarQueryParams.Add("sort_schema.direction", parameterToString(*r.sortSchemaDirection, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneMetadataByPostRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	v1GeneDatasetRequest *V1GeneDatasetRequest	
    Headers map[string]string
}

func (r *ApiGeneMetadataByPostRequest) V1GeneDatasetRequest(v1GeneDatasetRequest V1GeneDatasetRequest) *ApiGeneMetadataByPostRequest {
	r.v1GeneDatasetRequest = &v1GeneDatasetRequest
	return r
}

func (r ApiGeneMetadataByPostRequest) Execute() (V1GeneMetadata, *_nethttp.Response, error) {
	return r.ApiService.GeneMetadataByPostExecute(r)
}

/*
GeneMetadataByPost Get gene metadata as JSON

Get detailed gene metadata in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGeneMetadataByPostRequest
*/
func (a *GeneApiService) GeneMetadataByPost(ctx _context.Context, v1GeneDatasetRequest *V1GeneDatasetRequest) ApiGeneMetadataByPostRequest {
	return ApiGeneMetadataByPostRequest{
		ApiService: a,
		ctx: ctx,
		v1GeneDatasetRequest: v1GeneDatasetRequest,
	}
}

// Execute executes the request
//  @return V1GeneMetadata
func (a *GeneApiService) GeneMetadataByPostExecute(r ApiGeneMetadataByPostRequest) (V1GeneMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1GeneMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneMetadataByPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1GeneDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1GeneDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1GeneDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneMetadataByTaxAndSymbolRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	symbols []string	
	taxon string	
	accessions *[]string	
	returnedContent *V1GeneDatasetRequestContentType	
	sortSchemaField *V1GeneDatasetRequestSortField	
	sortSchemaDirection *V1SortDirection	
	limit *string	
    Headers map[string]string
}

// RNA or Protein accessions.
func (r *ApiGeneMetadataByTaxAndSymbolRequest) Accessions(accessions []string) *ApiGeneMetadataByTaxAndSymbolRequest {
	r.accessions = &accessions
	return r
}
// Return either gene-ids, or entire gene metadata
func (r *ApiGeneMetadataByTaxAndSymbolRequest) ReturnedContent(returnedContent V1GeneDatasetRequestContentType) *ApiGeneMetadataByTaxAndSymbolRequest {
	r.returnedContent = &returnedContent
	return r
}
// Select a field to sort on.
func (r *ApiGeneMetadataByTaxAndSymbolRequest) SortSchemaField(sortSchemaField V1GeneDatasetRequestSortField) *ApiGeneMetadataByTaxAndSymbolRequest {
	r.sortSchemaField = &sortSchemaField
	return r
}
// Select a direction for the sort.
func (r *ApiGeneMetadataByTaxAndSymbolRequest) SortSchemaDirection(sortSchemaDirection V1SortDirection) *ApiGeneMetadataByTaxAndSymbolRequest {
	r.sortSchemaDirection = &sortSchemaDirection
	return r
}
// Limit the number of returned results (\&quot;all\&quot;, \&quot;none\&quot;, otherwise an integer value)
func (r *ApiGeneMetadataByTaxAndSymbolRequest) Limit(limit string) *ApiGeneMetadataByTaxAndSymbolRequest {
	r.limit = &limit
	return r
}

func (r ApiGeneMetadataByTaxAndSymbolRequest) Execute() (V1GeneMetadata, *_nethttp.Response, error) {
	return r.ApiService.GeneMetadataByTaxAndSymbolExecute(r)
}

/*
GeneMetadataByTaxAndSymbol Get gene metadata by gene symbol

Get detailed gene metadata by gene symbol in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbols Gene symbol
 @param taxon Taxon for provided gene symbol
 @return ApiGeneMetadataByTaxAndSymbolRequest
*/
func (a *GeneApiService) GeneMetadataByTaxAndSymbol(ctx _context.Context, symbols []string, taxon string) ApiGeneMetadataByTaxAndSymbolRequest {
	return ApiGeneMetadataByTaxAndSymbolRequest{
		ApiService: a,
		ctx: ctx,
		symbols: symbols,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V1GeneMetadata
func (a *GeneApiService) GeneMetadataByTaxAndSymbolExecute(r ApiGeneMetadataByTaxAndSymbolRequest) (V1GeneMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1GeneMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneMetadataByTaxAndSymbol")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/symbol/{symbols}/taxon/{taxon}"
	localVarPath = strings.Replace(localVarPath, "{"+"symbols"+"}", _neturl.PathEscape(parameterToString(r.symbols, "csv")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.accessions != nil {
		t := *r.accessions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("accessions", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("accessions", parameterToString(t, "multi"))
		}
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.sortSchemaField != nil {
		localVarQueryParams.Add("sort_schema.field", parameterToString(*r.sortSchemaField, ""))
	}
	if r.sortSchemaDirection != nil {
		localVarQueryParams.Add("sort_schema.direction", parameterToString(*r.sortSchemaDirection, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneMetadataStreamByPostRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	v1GeneDatasetRequest *V1GeneDatasetRequest	
    Headers map[string]string
}

func (r *ApiGeneMetadataStreamByPostRequest) V1GeneDatasetRequest(v1GeneDatasetRequest V1GeneDatasetRequest) *ApiGeneMetadataStreamByPostRequest {
	r.v1GeneDatasetRequest = &v1GeneDatasetRequest
	return r
}

func (r ApiGeneMetadataStreamByPostRequest) Execute() (V1GeneMatch, *_nethttp.Response, error) {
	return r.ApiService.GeneMetadataStreamByPostExecute(r)
}

/*
GeneMetadataStreamByPost Get gene metadata

Get detailed gene metadata in a streaming, JSON-lines output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGeneMetadataStreamByPostRequest
*/
func (a *GeneApiService) GeneMetadataStreamByPost(ctx _context.Context, v1GeneDatasetRequest *V1GeneDatasetRequest) ApiGeneMetadataStreamByPostRequest {
	return ApiGeneMetadataStreamByPostRequest{
		ApiService: a,
		ctx: ctx,
		v1GeneDatasetRequest: v1GeneDatasetRequest,
	}
}

// Execute executes the request
//  @return V1GeneMatch
func (a *GeneApiService) GeneMetadataStreamByPostExecute(r ApiGeneMetadataStreamByPostRequest) (V1GeneMatch, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1GeneMatch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneMetadataStreamByPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/stream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1GeneDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1GeneDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-ndjson", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1GeneDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneOrthologsByIdRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	geneId int32	
	returnedContent *V1OrthologRequestContentType	
	taxonFilter *[]string	
    Headers map[string]string
}

// Return either gene-ids, or entire gene metadata
func (r *ApiGeneOrthologsByIdRequest) ReturnedContent(returnedContent V1OrthologRequestContentType) *ApiGeneOrthologsByIdRequest {
	r.returnedContent = &returnedContent
	return r
}
// Filter genes by taxa
func (r *ApiGeneOrthologsByIdRequest) TaxonFilter(taxonFilter []string) *ApiGeneOrthologsByIdRequest {
	r.taxonFilter = &taxonFilter
	return r
}

func (r ApiGeneOrthologsByIdRequest) Execute() (V1OrthologSet, *_nethttp.Response, error) {
	return r.ApiService.GeneOrthologsByIdExecute(r)
}

/*
GeneOrthologsById Get gene orthologs by gene ID

Get detailed gene metadata for an ortholog set by gene ID in a JSON output format.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geneId
 @return ApiGeneOrthologsByIdRequest
*/
func (a *GeneApiService) GeneOrthologsById(ctx _context.Context, geneId int32) ApiGeneOrthologsByIdRequest {
	return ApiGeneOrthologsByIdRequest{
		ApiService: a,
		ctx: ctx,
		geneId: geneId,
	}
}

// Execute executes the request
//  @return V1OrthologSet
func (a *GeneApiService) GeneOrthologsByIdExecute(r ApiGeneOrthologsByIdRequest) (V1OrthologSet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1OrthologSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneOrthologsById")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/id/{gene_id}/orthologs"
	localVarPath = strings.Replace(localVarPath, "{"+"gene_id"+"}", _neturl.PathEscape(parameterToString(r.geneId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.taxonFilter != nil {
		t := *r.taxonFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("taxon_filter", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("taxon_filter", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneTaxNameQueryRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	taxonQuery string	
	taxRankFilter *V1OrganismQueryRequestTaxRankFilter	
    Headers map[string]string
}

// Set the scope of searched tax ranks
func (r *ApiGeneTaxNameQueryRequest) TaxRankFilter(taxRankFilter V1OrganismQueryRequestTaxRankFilter) *ApiGeneTaxNameQueryRequest {
	r.taxRankFilter = &taxRankFilter
	return r
}

func (r ApiGeneTaxNameQueryRequest) Execute() (V1SciNameAndIds, *_nethttp.Response, error) {
	return r.ApiService.GeneTaxNameQueryExecute(r)
}

/*
GeneTaxNameQuery Get a list of taxonomy names and IDs found in the gene dataset given a partial taxonomic name

This endpoint retrieves a list of taxonomy names and IDs found in the gene dataset given a partial taxonomic name of any rank.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxonQuery NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return ApiGeneTaxNameQueryRequest
*/
func (a *GeneApiService) GeneTaxNameQuery(ctx _context.Context, taxonQuery string) ApiGeneTaxNameQueryRequest {
	return ApiGeneTaxNameQueryRequest{
		ApiService: a,
		ctx: ctx,
		taxonQuery: taxonQuery,
	}
}

// Execute executes the request
//  @return V1SciNameAndIds
func (a *GeneApiService) GeneTaxNameQueryExecute(r ApiGeneTaxNameQueryRequest) (V1SciNameAndIds, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1SciNameAndIds
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneTaxNameQuery")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/taxon_suggest/{taxon_query}"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon_query"+"}", _neturl.PathEscape(parameterToString(r.taxonQuery, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.taxRankFilter != nil {
		localVarQueryParams.Add("tax_rank_filter", parameterToString(*r.taxRankFilter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneTaxTreeRequest struct {
	ctx _context.Context
	ApiService *GeneApiService
	taxon string	
	childrenOnly *bool	
    Headers map[string]string
}

// Only report the children of the requested taxon and not their descendants
func (r *ApiGeneTaxTreeRequest) ChildrenOnly(childrenOnly bool) *ApiGeneTaxTreeRequest {
	r.childrenOnly = &childrenOnly
	return r
}

func (r ApiGeneTaxTreeRequest) Execute() (V1Organism, *_nethttp.Response, error) {
	return r.ApiService.GeneTaxTreeExecute(r)
}

/*
GeneTaxTree Get a taxonomic subtree by taxonomic identifier

Using an NCBI Taxonomy ID or name (common or scientific) at any rank, get a subtree filtered for species with assembled genomes.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return ApiGeneTaxTreeRequest
*/
func (a *GeneApiService) GeneTaxTree(ctx _context.Context, taxon string) ApiGeneTaxTreeRequest {
	return ApiGeneTaxTreeRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V1Organism
func (a *GeneApiService) GeneTaxTreeExecute(r ApiGeneTaxTreeRequest) (V1Organism, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1Organism
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GeneApiService.GeneTaxTree")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/gene/taxon/{taxon}/tree"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.childrenOnly != nil {
		localVarQueryParams.Add("children_only", parameterToString(*r.childrenOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
