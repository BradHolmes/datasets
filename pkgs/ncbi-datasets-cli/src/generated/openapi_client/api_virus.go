/*
NCBI Datasets API

### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated bag](https://www.ncbi.nlm.nih.gov/datasets/docs/v1/how-tos/genomes/large-download/), and retrieve the individual data files at a later time. 

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package datasets

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
	"time"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// VirusApiService VirusApi service
type VirusApiService service

type ApiSars2ProteinDownloadRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	proteins []string	
	refseqOnly *bool	
	annotatedOnly *bool	
	releasedSince *time.Time	
	updatedSince *time.Time	
	host *string	
	geoLocation *string	
	completeOnly *bool	
	includeAnnotationType *[]V1AnnotationForVirusType	
	filename *string	
    Headers map[string]string
}

// If true, limit results to RefSeq genomes.
func (r *ApiSars2ProteinDownloadRequest) RefseqOnly(refseqOnly bool) *ApiSars2ProteinDownloadRequest {
	r.refseqOnly = &refseqOnly
	return r
}
// If true, limit results to annotated genomes.
func (r *ApiSars2ProteinDownloadRequest) AnnotatedOnly(annotatedOnly bool) *ApiSars2ProteinDownloadRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r *ApiSars2ProteinDownloadRequest) ReleasedSince(releasedSince time.Time) *ApiSars2ProteinDownloadRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiSars2ProteinDownloadRequest) UpdatedSince(updatedSince time.Time) *ApiSars2ProteinDownloadRequest {
	r.updatedSince = &updatedSince
	return r
}
// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r *ApiSars2ProteinDownloadRequest) Host(host string) *ApiSars2ProteinDownloadRequest {
	r.host = &host
	return r
}
// Assemblies from this location (country and state, or continent)
func (r *ApiSars2ProteinDownloadRequest) GeoLocation(geoLocation string) *ApiSars2ProteinDownloadRequest {
	r.geoLocation = &geoLocation
	return r
}
// only include complete genomes.
func (r *ApiSars2ProteinDownloadRequest) CompleteOnly(completeOnly bool) *ApiSars2ProteinDownloadRequest {
	r.completeOnly = &completeOnly
	return r
}
// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r *ApiSars2ProteinDownloadRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForVirusType) *ApiSars2ProteinDownloadRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}
// Output file name.
func (r *ApiSars2ProteinDownloadRequest) Filename(filename string) *ApiSars2ProteinDownloadRequest {
	r.filename = &filename
	return r
}

func (r ApiSars2ProteinDownloadRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.Sars2ProteinDownloadExecute(r)
}

/*
Sars2ProteinDownload Download SARS-CoV-2 protein and CDS datasets by protein name

Download a SARS-CoV-2 protein datasets
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param proteins Which proteins to retrieve in the data package
 @return ApiSars2ProteinDownloadRequest
*/
func (a *VirusApiService) Sars2ProteinDownload(ctx _context.Context, proteins []string) ApiSars2ProteinDownloadRequest {
	return ApiSars2ProteinDownloadRequest{
		ApiService: a,
		ctx: ctx,
		proteins: proteins,
	}
}

// Execute executes the request
//  @return *os.File
func (a *VirusApiService) Sars2ProteinDownloadExecute(r ApiSars2ProteinDownloadRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinDownload")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein/{proteins}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"proteins"+"}", _neturl.PathEscape(parameterToString(r.proteins, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSars2ProteinSummaryRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	proteins []string	
	refseqOnly *bool	
	annotatedOnly *bool	
	releasedSince *time.Time	
	updatedSince *time.Time	
	host *string	
	geoLocation *string	
	completeOnly *bool	
	includeAnnotationType *[]V1AnnotationForVirusType	
    Headers map[string]string
}

// If true, limit results to RefSeq genomes.
func (r *ApiSars2ProteinSummaryRequest) RefseqOnly(refseqOnly bool) *ApiSars2ProteinSummaryRequest {
	r.refseqOnly = &refseqOnly
	return r
}
// If true, limit results to annotated genomes.
func (r *ApiSars2ProteinSummaryRequest) AnnotatedOnly(annotatedOnly bool) *ApiSars2ProteinSummaryRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r *ApiSars2ProteinSummaryRequest) ReleasedSince(releasedSince time.Time) *ApiSars2ProteinSummaryRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiSars2ProteinSummaryRequest) UpdatedSince(updatedSince time.Time) *ApiSars2ProteinSummaryRequest {
	r.updatedSince = &updatedSince
	return r
}
// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r *ApiSars2ProteinSummaryRequest) Host(host string) *ApiSars2ProteinSummaryRequest {
	r.host = &host
	return r
}
// Assemblies from this location (country and state, or continent)
func (r *ApiSars2ProteinSummaryRequest) GeoLocation(geoLocation string) *ApiSars2ProteinSummaryRequest {
	r.geoLocation = &geoLocation
	return r
}
// only include complete genomes.
func (r *ApiSars2ProteinSummaryRequest) CompleteOnly(completeOnly bool) *ApiSars2ProteinSummaryRequest {
	r.completeOnly = &completeOnly
	return r
}
// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r *ApiSars2ProteinSummaryRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForVirusType) *ApiSars2ProteinSummaryRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

func (r ApiSars2ProteinSummaryRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.Sars2ProteinSummaryExecute(r)
}

/*
Sars2ProteinSummary Summary of SARS-CoV-2 protein and CDS datasets by protein name

Download a summary of available SARS-CoV-2 protein datasets
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param proteins Which proteins to retrieve in the data package
 @return ApiSars2ProteinSummaryRequest
*/
func (a *VirusApiService) Sars2ProteinSummary(ctx _context.Context, proteins []string) ApiSars2ProteinSummaryRequest {
	return ApiSars2ProteinSummaryRequest{
		ApiService: a,
		ctx: ctx,
		proteins: proteins,
	}
}

// Execute executes the request
//  @return V1DownloadSummary
func (a *VirusApiService) Sars2ProteinSummaryExecute(r ApiSars2ProteinSummaryRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein/{proteins}"
	localVarPath = strings.Replace(localVarPath, "{"+"proteins"+"}", _neturl.PathEscape(parameterToString(r.proteins, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSars2ProteinTableRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	proteins []string	
	refseqOnly *bool	
	annotatedOnly *bool	
	releasedSince *time.Time	
	updatedSince *time.Time	
	host *string	
	geoLocation *string	
	completeOnly *bool	
	tableFields *[]V1VirusTableField	
	format *V1TableFormat	
    Headers map[string]string
}

// If true, limit results to RefSeq genomes.
func (r *ApiSars2ProteinTableRequest) RefseqOnly(refseqOnly bool) *ApiSars2ProteinTableRequest {
	r.refseqOnly = &refseqOnly
	return r
}
// If true, limit results to annotated genomes.
func (r *ApiSars2ProteinTableRequest) AnnotatedOnly(annotatedOnly bool) *ApiSars2ProteinTableRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r *ApiSars2ProteinTableRequest) ReleasedSince(releasedSince time.Time) *ApiSars2ProteinTableRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiSars2ProteinTableRequest) UpdatedSince(updatedSince time.Time) *ApiSars2ProteinTableRequest {
	r.updatedSince = &updatedSince
	return r
}
// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r *ApiSars2ProteinTableRequest) Host(host string) *ApiSars2ProteinTableRequest {
	r.host = &host
	return r
}
// Assemblies from this location (country and state, or continent)
func (r *ApiSars2ProteinTableRequest) GeoLocation(geoLocation string) *ApiSars2ProteinTableRequest {
	r.geoLocation = &geoLocation
	return r
}
// only include complete genomes.
func (r *ApiSars2ProteinTableRequest) CompleteOnly(completeOnly bool) *ApiSars2ProteinTableRequest {
	r.completeOnly = &completeOnly
	return r
}
// Specify which fields to include in the tabular report
func (r *ApiSars2ProteinTableRequest) TableFields(tableFields []V1VirusTableField) *ApiSars2ProteinTableRequest {
	r.tableFields = &tableFields
	return r
}
// Choose download format (tsv, csv or jsonl)
func (r *ApiSars2ProteinTableRequest) Format(format V1TableFormat) *ApiSars2ProteinTableRequest {
	r.format = &format
	return r
}

func (r ApiSars2ProteinTableRequest) Execute() (V1TabularOutput, *_nethttp.Response, error) {
	return r.ApiService.Sars2ProteinTableExecute(r)
}

/*
Sars2ProteinTable Get SARS-CoV-2 protein metadata in a tabular format.

Get protein metadata in tabular format for SARS-CoV-2 genomes.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param proteins Which proteins to retrieve in the data package
 @return ApiSars2ProteinTableRequest
*/
func (a *VirusApiService) Sars2ProteinTable(ctx _context.Context, proteins []string) ApiSars2ProteinTableRequest {
	return ApiSars2ProteinTableRequest{
		ApiService: a,
		ctx: ctx,
		proteins: proteins,
	}
}

// Execute executes the request
//  @return V1TabularOutput
func (a *VirusApiService) Sars2ProteinTableExecute(r ApiSars2ProteinTableRequest) (V1TabularOutput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1TabularOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinTable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein/{proteins}/table"
	localVarPath = strings.Replace(localVarPath, "{"+"proteins"+"}", _neturl.PathEscape(parameterToString(r.proteins, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusGenomeDownloadRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	taxon string	
	refseqOnly *bool	
	annotatedOnly *bool	
	releasedSince *time.Time	
	updatedSince *time.Time	
	host *string	
	pangolinClassification *string	
	geoLocation *string	
	completeOnly *bool	
	excludeSequence *bool	
	includeAnnotationType *[]V1AnnotationForVirusType	
	filename *string	
    Headers map[string]string
}

// If true, limit results to RefSeq genomes.
func (r *ApiVirusGenomeDownloadRequest) RefseqOnly(refseqOnly bool) *ApiVirusGenomeDownloadRequest {
	r.refseqOnly = &refseqOnly
	return r
}
// If true, limit results to annotated genomes.
func (r *ApiVirusGenomeDownloadRequest) AnnotatedOnly(annotatedOnly bool) *ApiVirusGenomeDownloadRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r *ApiVirusGenomeDownloadRequest) ReleasedSince(releasedSince time.Time) *ApiVirusGenomeDownloadRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiVirusGenomeDownloadRequest) UpdatedSince(updatedSince time.Time) *ApiVirusGenomeDownloadRequest {
	r.updatedSince = &updatedSince
	return r
}
// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r *ApiVirusGenomeDownloadRequest) Host(host string) *ApiVirusGenomeDownloadRequest {
	r.host = &host
	return r
}
// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r *ApiVirusGenomeDownloadRequest) PangolinClassification(pangolinClassification string) *ApiVirusGenomeDownloadRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}
// Assemblies from this location (country and state, or continent)
func (r *ApiVirusGenomeDownloadRequest) GeoLocation(geoLocation string) *ApiVirusGenomeDownloadRequest {
	r.geoLocation = &geoLocation
	return r
}
// only include complete genomes.
func (r *ApiVirusGenomeDownloadRequest) CompleteOnly(completeOnly bool) *ApiVirusGenomeDownloadRequest {
	r.completeOnly = &completeOnly
	return r
}
// Set to true to omit the genomic sequence.
func (r *ApiVirusGenomeDownloadRequest) ExcludeSequence(excludeSequence bool) *ApiVirusGenomeDownloadRequest {
	r.excludeSequence = &excludeSequence
	return r
}
// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r *ApiVirusGenomeDownloadRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForVirusType) *ApiVirusGenomeDownloadRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}
// Output file name.
func (r *ApiVirusGenomeDownloadRequest) Filename(filename string) *ApiVirusGenomeDownloadRequest {
	r.filename = &filename
	return r
}

func (r ApiVirusGenomeDownloadRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.VirusGenomeDownloadExecute(r)
}

/*
VirusGenomeDownload Download a coronavirus genome dataset by taxon

Download a coronavirus genome dataset by taxon
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return ApiVirusGenomeDownloadRequest
*/
func (a *VirusApiService) VirusGenomeDownload(ctx _context.Context, taxon string) ApiVirusGenomeDownloadRequest {
	return ApiVirusGenomeDownloadRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return *os.File
func (a *VirusApiService) VirusGenomeDownloadExecute(r ApiVirusGenomeDownloadRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeDownload")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/genome/download"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.excludeSequence != nil {
		localVarQueryParams.Add("exclude_sequence", parameterToString(*r.excludeSequence, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusGenomeDownloadAccessionRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	accessions []string	
	refseqOnly *bool	
	annotatedOnly *bool	
	releasedSince *time.Time	
	updatedSince *time.Time	
	host *string	
	pangolinClassification *string	
	geoLocation *string	
	completeOnly *bool	
	excludeSequence *bool	
	includeAnnotationType *[]V1AnnotationForVirusType	
	filename *string	
    Headers map[string]string
}

// If true, limit results to RefSeq genomes.
func (r *ApiVirusGenomeDownloadAccessionRequest) RefseqOnly(refseqOnly bool) *ApiVirusGenomeDownloadAccessionRequest {
	r.refseqOnly = &refseqOnly
	return r
}
// If true, limit results to annotated genomes.
func (r *ApiVirusGenomeDownloadAccessionRequest) AnnotatedOnly(annotatedOnly bool) *ApiVirusGenomeDownloadAccessionRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r *ApiVirusGenomeDownloadAccessionRequest) ReleasedSince(releasedSince time.Time) *ApiVirusGenomeDownloadAccessionRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiVirusGenomeDownloadAccessionRequest) UpdatedSince(updatedSince time.Time) *ApiVirusGenomeDownloadAccessionRequest {
	r.updatedSince = &updatedSince
	return r
}
// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r *ApiVirusGenomeDownloadAccessionRequest) Host(host string) *ApiVirusGenomeDownloadAccessionRequest {
	r.host = &host
	return r
}
// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r *ApiVirusGenomeDownloadAccessionRequest) PangolinClassification(pangolinClassification string) *ApiVirusGenomeDownloadAccessionRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}
// Assemblies from this location (country and state, or continent)
func (r *ApiVirusGenomeDownloadAccessionRequest) GeoLocation(geoLocation string) *ApiVirusGenomeDownloadAccessionRequest {
	r.geoLocation = &geoLocation
	return r
}
// only include complete genomes.
func (r *ApiVirusGenomeDownloadAccessionRequest) CompleteOnly(completeOnly bool) *ApiVirusGenomeDownloadAccessionRequest {
	r.completeOnly = &completeOnly
	return r
}
// Set to true to omit the genomic sequence.
func (r *ApiVirusGenomeDownloadAccessionRequest) ExcludeSequence(excludeSequence bool) *ApiVirusGenomeDownloadAccessionRequest {
	r.excludeSequence = &excludeSequence
	return r
}
// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r *ApiVirusGenomeDownloadAccessionRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForVirusType) *ApiVirusGenomeDownloadAccessionRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}
// Output file name.
func (r *ApiVirusGenomeDownloadAccessionRequest) Filename(filename string) *ApiVirusGenomeDownloadAccessionRequest {
	r.filename = &filename
	return r
}

func (r ApiVirusGenomeDownloadAccessionRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.VirusGenomeDownloadAccessionExecute(r)
}

/*
VirusGenomeDownloadAccession Download a coronavirus genome dataset by accession

Download a coronavirus genome dataset by accession
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions Accessions accessions = 16;
 @return ApiVirusGenomeDownloadAccessionRequest
*/
func (a *VirusApiService) VirusGenomeDownloadAccession(ctx _context.Context, accessions []string) ApiVirusGenomeDownloadAccessionRequest {
	return ApiVirusGenomeDownloadAccessionRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return *os.File
func (a *VirusApiService) VirusGenomeDownloadAccessionExecute(r ApiVirusGenomeDownloadAccessionRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeDownloadAccession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/accession/{accessions}/genome/download"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.excludeSequence != nil {
		localVarQueryParams.Add("exclude_sequence", parameterToString(*r.excludeSequence, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusGenomeDownloadPostRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	v1VirusDatasetRequest *V1VirusDatasetRequest	
	filename *string	
    Headers map[string]string
}

func (r *ApiVirusGenomeDownloadPostRequest) V1VirusDatasetRequest(v1VirusDatasetRequest V1VirusDatasetRequest) *ApiVirusGenomeDownloadPostRequest {
	r.v1VirusDatasetRequest = &v1VirusDatasetRequest
	return r
}
// Output file name.
func (r *ApiVirusGenomeDownloadPostRequest) Filename(filename string) *ApiVirusGenomeDownloadPostRequest {
	r.filename = &filename
	return r
}

func (r ApiVirusGenomeDownloadPostRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.VirusGenomeDownloadPostExecute(r)
}

/*
VirusGenomeDownloadPost Get a coronavirus genome dataset by post

The 'GET' version of download is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirusGenomeDownloadPostRequest
*/
func (a *VirusApiService) VirusGenomeDownloadPost(ctx _context.Context, v1VirusDatasetRequest *V1VirusDatasetRequest) ApiVirusGenomeDownloadPostRequest {
	return ApiVirusGenomeDownloadPostRequest{
		ApiService: a,
		ctx: ctx,
		v1VirusDatasetRequest: v1VirusDatasetRequest,
	}
}

// Execute executes the request
//  @return *os.File
func (a *VirusApiService) VirusGenomeDownloadPostExecute(r ApiVirusGenomeDownloadPostRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeDownloadPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/genome/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1VirusDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1VirusDatasetRequest is required and must be specified")
	}

	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1VirusDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusGenomeSummaryRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	taxon string	
	refseqOnly *bool	
	annotatedOnly *bool	
	releasedSince *time.Time	
	updatedSince *time.Time	
	host *string	
	pangolinClassification *string	
	geoLocation *string	
	completeOnly *bool	
	excludeSequence *bool	
	includeAnnotationType *[]V1AnnotationForVirusType	
    Headers map[string]string
}

// If true, limit results to RefSeq genomes.
func (r *ApiVirusGenomeSummaryRequest) RefseqOnly(refseqOnly bool) *ApiVirusGenomeSummaryRequest {
	r.refseqOnly = &refseqOnly
	return r
}
// If true, limit results to annotated genomes.
func (r *ApiVirusGenomeSummaryRequest) AnnotatedOnly(annotatedOnly bool) *ApiVirusGenomeSummaryRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r *ApiVirusGenomeSummaryRequest) ReleasedSince(releasedSince time.Time) *ApiVirusGenomeSummaryRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiVirusGenomeSummaryRequest) UpdatedSince(updatedSince time.Time) *ApiVirusGenomeSummaryRequest {
	r.updatedSince = &updatedSince
	return r
}
// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r *ApiVirusGenomeSummaryRequest) Host(host string) *ApiVirusGenomeSummaryRequest {
	r.host = &host
	return r
}
// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r *ApiVirusGenomeSummaryRequest) PangolinClassification(pangolinClassification string) *ApiVirusGenomeSummaryRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}
// Assemblies from this location (country and state, or continent)
func (r *ApiVirusGenomeSummaryRequest) GeoLocation(geoLocation string) *ApiVirusGenomeSummaryRequest {
	r.geoLocation = &geoLocation
	return r
}
// only include complete genomes.
func (r *ApiVirusGenomeSummaryRequest) CompleteOnly(completeOnly bool) *ApiVirusGenomeSummaryRequest {
	r.completeOnly = &completeOnly
	return r
}
// Set to true to omit the genomic sequence.
func (r *ApiVirusGenomeSummaryRequest) ExcludeSequence(excludeSequence bool) *ApiVirusGenomeSummaryRequest {
	r.excludeSequence = &excludeSequence
	return r
}
// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r *ApiVirusGenomeSummaryRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForVirusType) *ApiVirusGenomeSummaryRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

func (r ApiVirusGenomeSummaryRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.VirusGenomeSummaryExecute(r)
}

/*
VirusGenomeSummary Get summary data for Coronaviridae genomes by taxon

Get summary data and download by command line instructions for Coronaviridae genomes by taxon.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return ApiVirusGenomeSummaryRequest
*/
func (a *VirusApiService) VirusGenomeSummary(ctx _context.Context, taxon string) ApiVirusGenomeSummaryRequest {
	return ApiVirusGenomeSummaryRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V1DownloadSummary
func (a *VirusApiService) VirusGenomeSummaryExecute(r ApiVirusGenomeSummaryRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/genome"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.excludeSequence != nil {
		localVarQueryParams.Add("exclude_sequence", parameterToString(*r.excludeSequence, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusGenomeSummaryAccessionRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	accessions []string	
	refseqOnly *bool	
	annotatedOnly *bool	
	releasedSince *time.Time	
	updatedSince *time.Time	
	host *string	
	pangolinClassification *string	
	geoLocation *string	
	completeOnly *bool	
	excludeSequence *bool	
	includeAnnotationType *[]V1AnnotationForVirusType	
    Headers map[string]string
}

// If true, limit results to RefSeq genomes.
func (r *ApiVirusGenomeSummaryAccessionRequest) RefseqOnly(refseqOnly bool) *ApiVirusGenomeSummaryAccessionRequest {
	r.refseqOnly = &refseqOnly
	return r
}
// If true, limit results to annotated genomes.
func (r *ApiVirusGenomeSummaryAccessionRequest) AnnotatedOnly(annotatedOnly bool) *ApiVirusGenomeSummaryAccessionRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r *ApiVirusGenomeSummaryAccessionRequest) ReleasedSince(releasedSince time.Time) *ApiVirusGenomeSummaryAccessionRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiVirusGenomeSummaryAccessionRequest) UpdatedSince(updatedSince time.Time) *ApiVirusGenomeSummaryAccessionRequest {
	r.updatedSince = &updatedSince
	return r
}
// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r *ApiVirusGenomeSummaryAccessionRequest) Host(host string) *ApiVirusGenomeSummaryAccessionRequest {
	r.host = &host
	return r
}
// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r *ApiVirusGenomeSummaryAccessionRequest) PangolinClassification(pangolinClassification string) *ApiVirusGenomeSummaryAccessionRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}
// Assemblies from this location (country and state, or continent)
func (r *ApiVirusGenomeSummaryAccessionRequest) GeoLocation(geoLocation string) *ApiVirusGenomeSummaryAccessionRequest {
	r.geoLocation = &geoLocation
	return r
}
// only include complete genomes.
func (r *ApiVirusGenomeSummaryAccessionRequest) CompleteOnly(completeOnly bool) *ApiVirusGenomeSummaryAccessionRequest {
	r.completeOnly = &completeOnly
	return r
}
// Set to true to omit the genomic sequence.
func (r *ApiVirusGenomeSummaryAccessionRequest) ExcludeSequence(excludeSequence bool) *ApiVirusGenomeSummaryAccessionRequest {
	r.excludeSequence = &excludeSequence
	return r
}
// Select additional types of annotation to include in the data package.  If unset, no annotation is provided.
func (r *ApiVirusGenomeSummaryAccessionRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForVirusType) *ApiVirusGenomeSummaryAccessionRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

func (r ApiVirusGenomeSummaryAccessionRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.VirusGenomeSummaryAccessionExecute(r)
}

/*
VirusGenomeSummaryAccession Get summary data for Coronaviridae genomes by accession

Get summary data for Coronaviridae genomes by accession
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions Accessions accessions = 16;
 @return ApiVirusGenomeSummaryAccessionRequest
*/
func (a *VirusApiService) VirusGenomeSummaryAccession(ctx _context.Context, accessions []string) ApiVirusGenomeSummaryAccessionRequest {
	return ApiVirusGenomeSummaryAccessionRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V1DownloadSummary
func (a *VirusApiService) VirusGenomeSummaryAccessionExecute(r ApiVirusGenomeSummaryAccessionRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeSummaryAccession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/accession/{accessions}/genome"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.excludeSequence != nil {
		localVarQueryParams.Add("exclude_sequence", parameterToString(*r.excludeSequence, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusGenomeSummaryPostRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	v1VirusDatasetRequest *V1VirusDatasetRequest	
    Headers map[string]string
}

func (r *ApiVirusGenomeSummaryPostRequest) V1VirusDatasetRequest(v1VirusDatasetRequest V1VirusDatasetRequest) *ApiVirusGenomeSummaryPostRequest {
	r.v1VirusDatasetRequest = &v1VirusDatasetRequest
	return r
}

func (r ApiVirusGenomeSummaryPostRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.VirusGenomeSummaryPostExecute(r)
}

/*
VirusGenomeSummaryPost Get summary data for Coronaviridae genomes by post

The 'GET' version is limited by the size of the GET URL (2KB, which works out to about 140 genomic accessions).  The POST operation is provided to allow users to supply a larger number of accessions in a single request.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirusGenomeSummaryPostRequest
*/
func (a *VirusApiService) VirusGenomeSummaryPost(ctx _context.Context, v1VirusDatasetRequest *V1VirusDatasetRequest) ApiVirusGenomeSummaryPostRequest {
	return ApiVirusGenomeSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
		v1VirusDatasetRequest: v1VirusDatasetRequest,
	}
}

// Execute executes the request
//  @return V1DownloadSummary
func (a *VirusApiService) VirusGenomeSummaryPostExecute(r ApiVirusGenomeSummaryPostRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeSummaryPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/genome"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1VirusDatasetRequest == nil {
		return localVarReturnValue, nil, reportError("v1VirusDatasetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1VirusDatasetRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusGenomeTableRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	taxon string	
	refseqOnly *bool	
	annotatedOnly *bool	
	releasedSince *time.Time	
	updatedSince *time.Time	
	host *string	
	pangolinClassification *string	
	geoLocation *string	
	completeOnly *bool	
	tableFields *[]V1VirusTableField	
	format *V1TableFormat	
    Headers map[string]string
}

// If true, limit results to RefSeq genomes.
func (r *ApiVirusGenomeTableRequest) RefseqOnly(refseqOnly bool) *ApiVirusGenomeTableRequest {
	r.refseqOnly = &refseqOnly
	return r
}
// If true, limit results to annotated genomes.
func (r *ApiVirusGenomeTableRequest) AnnotatedOnly(annotatedOnly bool) *ApiVirusGenomeTableRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r *ApiVirusGenomeTableRequest) ReleasedSince(releasedSince time.Time) *ApiVirusGenomeTableRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiVirusGenomeTableRequest) UpdatedSince(updatedSince time.Time) *ApiVirusGenomeTableRequest {
	r.updatedSince = &updatedSince
	return r
}
// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r *ApiVirusGenomeTableRequest) Host(host string) *ApiVirusGenomeTableRequest {
	r.host = &host
	return r
}
// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r *ApiVirusGenomeTableRequest) PangolinClassification(pangolinClassification string) *ApiVirusGenomeTableRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}
// Assemblies from this location (country and state, or continent)
func (r *ApiVirusGenomeTableRequest) GeoLocation(geoLocation string) *ApiVirusGenomeTableRequest {
	r.geoLocation = &geoLocation
	return r
}
// only include complete genomes.
func (r *ApiVirusGenomeTableRequest) CompleteOnly(completeOnly bool) *ApiVirusGenomeTableRequest {
	r.completeOnly = &completeOnly
	return r
}
// Specify which fields to include in the tabular report
func (r *ApiVirusGenomeTableRequest) TableFields(tableFields []V1VirusTableField) *ApiVirusGenomeTableRequest {
	r.tableFields = &tableFields
	return r
}
// Choose download format (tsv, csv or jsonl)
func (r *ApiVirusGenomeTableRequest) Format(format V1TableFormat) *ApiVirusGenomeTableRequest {
	r.format = &format
	return r
}

func (r ApiVirusGenomeTableRequest) Execute() (V1TabularOutput, *_nethttp.Response, error) {
	return r.ApiService.VirusGenomeTableExecute(r)
}

/*
VirusGenomeTable Get viral genomic metadata in a tabular format.

Get viral genomic metadata in tabular format for Coronaviridae genomes by taxon.
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return ApiVirusGenomeTableRequest
*/
func (a *VirusApiService) VirusGenomeTable(ctx _context.Context, taxon string) ApiVirusGenomeTableRequest {
	return ApiVirusGenomeTableRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V1TabularOutput
func (a *VirusApiService) VirusGenomeTableExecute(r ApiVirusGenomeTableRequest) (V1TabularOutput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1TabularOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeTable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/genome/table"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusReportsByAcessionsRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	accessions []string	
	filterRefseqOnly *bool	
	filterAnnotatedOnly *bool	
	filterReleasedSince *time.Time	
	filterUpdatedSince *time.Time	
	filterHost *string	
	filterPangolinClassification *string	
	filterGeoLocation *string	
	filterCompleteOnly *bool	
	returnedContent *V1VirusDataReportRequestContentType	
	tableFields *[]string	
	pageSize *int32	
	pageToken *string	
    Headers map[string]string
}

// If true, limit results to RefSeq genomes.
func (r *ApiVirusReportsByAcessionsRequest) FilterRefseqOnly(filterRefseqOnly bool) *ApiVirusReportsByAcessionsRequest {
	r.filterRefseqOnly = &filterRefseqOnly
	return r
}
// If true, limit results to annotated genomes.
func (r *ApiVirusReportsByAcessionsRequest) FilterAnnotatedOnly(filterAnnotatedOnly bool) *ApiVirusReportsByAcessionsRequest {
	r.filterAnnotatedOnly = &filterAnnotatedOnly
	return r
}
// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r *ApiVirusReportsByAcessionsRequest) FilterReleasedSince(filterReleasedSince time.Time) *ApiVirusReportsByAcessionsRequest {
	r.filterReleasedSince = &filterReleasedSince
	return r
}
func (r *ApiVirusReportsByAcessionsRequest) FilterUpdatedSince(filterUpdatedSince time.Time) *ApiVirusReportsByAcessionsRequest {
	r.filterUpdatedSince = &filterUpdatedSince
	return r
}
// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r *ApiVirusReportsByAcessionsRequest) FilterHost(filterHost string) *ApiVirusReportsByAcessionsRequest {
	r.filterHost = &filterHost
	return r
}
// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r *ApiVirusReportsByAcessionsRequest) FilterPangolinClassification(filterPangolinClassification string) *ApiVirusReportsByAcessionsRequest {
	r.filterPangolinClassification = &filterPangolinClassification
	return r
}
// Assemblies from this location (country and state, or continent)
func (r *ApiVirusReportsByAcessionsRequest) FilterGeoLocation(filterGeoLocation string) *ApiVirusReportsByAcessionsRequest {
	r.filterGeoLocation = &filterGeoLocation
	return r
}
// only include complete genomes.
func (r *ApiVirusReportsByAcessionsRequest) FilterCompleteOnly(filterCompleteOnly bool) *ApiVirusReportsByAcessionsRequest {
	r.filterCompleteOnly = &filterCompleteOnly
	return r
}
// Return either virus genome accessions, or complete virus metadata
func (r *ApiVirusReportsByAcessionsRequest) ReturnedContent(returnedContent V1VirusDataReportRequestContentType) *ApiVirusReportsByAcessionsRequest {
	r.returnedContent = &returnedContent
	return r
}
// Specify which fields to include in the tabular report
func (r *ApiVirusReportsByAcessionsRequest) TableFields(tableFields []string) *ApiVirusReportsByAcessionsRequest {
	r.tableFields = &tableFields
	return r
}
// The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r *ApiVirusReportsByAcessionsRequest) PageSize(pageSize int32) *ApiVirusReportsByAcessionsRequest {
	r.pageSize = &pageSize
	return r
}
// A page token is returned from a &#x60;GetVirusDataReports&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;VirusDataReportRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r *ApiVirusReportsByAcessionsRequest) PageToken(pageToken string) *ApiVirusReportsByAcessionsRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiVirusReportsByAcessionsRequest) Execute() (V1reportsVirusDataReportPage, *_nethttp.Response, error) {
	return r.ApiService.VirusReportsByAcessionsExecute(r)
}

/*
VirusReportsByAcessions Get virus metadata by accession

Get virus metadata by accesion. By default, in paged JSON format, but also available as tabular (accept: x-tabular) or json-lines (accept: x-jsonlines)
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessions genome sequence accessions
 @return ApiVirusReportsByAcessionsRequest
*/
func (a *VirusApiService) VirusReportsByAcessions(ctx _context.Context, accessions []string) ApiVirusReportsByAcessionsRequest {
	return ApiVirusReportsByAcessionsRequest{
		ApiService: a,
		ctx: ctx,
		accessions: accessions,
	}
}

// Execute executes the request
//  @return V1reportsVirusDataReportPage
func (a *VirusApiService) VirusReportsByAcessionsExecute(r ApiVirusReportsByAcessionsRequest) (V1reportsVirusDataReportPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1reportsVirusDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusReportsByAcessions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/accession/{accessions}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"accessions"+"}", _neturl.PathEscape(parameterToString(r.accessions, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filterRefseqOnly != nil {
		localVarQueryParams.Add("filter.refseq_only", parameterToString(*r.filterRefseqOnly, ""))
	}
	if r.filterAnnotatedOnly != nil {
		localVarQueryParams.Add("filter.annotated_only", parameterToString(*r.filterAnnotatedOnly, ""))
	}
	if r.filterReleasedSince != nil {
		localVarQueryParams.Add("filter.released_since", parameterToString(*r.filterReleasedSince, ""))
	}
	if r.filterUpdatedSince != nil {
		localVarQueryParams.Add("filter.updated_since", parameterToString(*r.filterUpdatedSince, ""))
	}
	if r.filterHost != nil {
		localVarQueryParams.Add("filter.host", parameterToString(*r.filterHost, ""))
	}
	if r.filterPangolinClassification != nil {
		localVarQueryParams.Add("filter.pangolin_classification", parameterToString(*r.filterPangolinClassification, ""))
	}
	if r.filterGeoLocation != nil {
		localVarQueryParams.Add("filter.geo_location", parameterToString(*r.filterGeoLocation, ""))
	}
	if r.filterCompleteOnly != nil {
		localVarQueryParams.Add("filter.complete_only", parameterToString(*r.filterCompleteOnly, ""))
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusReportsByPostRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	v1VirusDataReportRequest *V1VirusDataReportRequest	
    Headers map[string]string
}

func (r *ApiVirusReportsByPostRequest) V1VirusDataReportRequest(v1VirusDataReportRequest V1VirusDataReportRequest) *ApiVirusReportsByPostRequest {
	r.v1VirusDataReportRequest = &v1VirusDataReportRequest
	return r
}

func (r ApiVirusReportsByPostRequest) Execute() (V1reportsVirusDataReportPage, *_nethttp.Response, error) {
	return r.ApiService.VirusReportsByPostExecute(r)
}

/*
VirusReportsByPost Get virus metadata by POST

Get virus metadata. By default, in paged JSON format, but also available as tabular (accept: x-tabular) or json-lines (accept: x-jsonlines)
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVirusReportsByPostRequest
*/
func (a *VirusApiService) VirusReportsByPost(ctx _context.Context, v1VirusDataReportRequest *V1VirusDataReportRequest) ApiVirusReportsByPostRequest {
	return ApiVirusReportsByPostRequest{
		ApiService: a,
		ctx: ctx,
		v1VirusDataReportRequest: v1VirusDataReportRequest,
	}
}

// Execute executes the request
//  @return V1reportsVirusDataReportPage
func (a *VirusApiService) VirusReportsByPostExecute(r ApiVirusReportsByPostRequest) (V1reportsVirusDataReportPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1reportsVirusDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusReportsByPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.v1VirusDataReportRequest == nil {
		return localVarReturnValue, nil, reportError("v1VirusDataReportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	// body params
	localVarPostBody = r.v1VirusDataReportRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusReportsByTaxonRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	taxon string	
	filterRefseqOnly *bool	
	filterAnnotatedOnly *bool	
	filterReleasedSince *time.Time	
	filterUpdatedSince *time.Time	
	filterHost *string	
	filterPangolinClassification *string	
	filterGeoLocation *string	
	filterCompleteOnly *bool	
	returnedContent *V1VirusDataReportRequestContentType	
	tableFields *[]string	
	pageSize *int32	
	pageToken *string	
    Headers map[string]string
}

// If true, limit results to RefSeq genomes.
func (r *ApiVirusReportsByTaxonRequest) FilterRefseqOnly(filterRefseqOnly bool) *ApiVirusReportsByTaxonRequest {
	r.filterRefseqOnly = &filterRefseqOnly
	return r
}
// If true, limit results to annotated genomes.
func (r *ApiVirusReportsByTaxonRequest) FilterAnnotatedOnly(filterAnnotatedOnly bool) *ApiVirusReportsByTaxonRequest {
	r.filterAnnotatedOnly = &filterAnnotatedOnly
	return r
}
// If set, limit results to viral genomes that have been released after a specified date (and optionally, time). April 1, 2020 midnight UTC should be formatted as &#39;2020-04-01T00:00:00.000Z&#39;
func (r *ApiVirusReportsByTaxonRequest) FilterReleasedSince(filterReleasedSince time.Time) *ApiVirusReportsByTaxonRequest {
	r.filterReleasedSince = &filterReleasedSince
	return r
}
func (r *ApiVirusReportsByTaxonRequest) FilterUpdatedSince(filterUpdatedSince time.Time) *ApiVirusReportsByTaxonRequest {
	r.filterUpdatedSince = &filterUpdatedSince
	return r
}
// If set, limit results to genomes extracted from this host (Taxonomy ID or name) All hosts by default
func (r *ApiVirusReportsByTaxonRequest) FilterHost(filterHost string) *ApiVirusReportsByTaxonRequest {
	r.filterHost = &filterHost
	return r
}
// If set, limit results to genomes classified to this lineage by the PangoLearn tool.
func (r *ApiVirusReportsByTaxonRequest) FilterPangolinClassification(filterPangolinClassification string) *ApiVirusReportsByTaxonRequest {
	r.filterPangolinClassification = &filterPangolinClassification
	return r
}
// Assemblies from this location (country and state, or continent)
func (r *ApiVirusReportsByTaxonRequest) FilterGeoLocation(filterGeoLocation string) *ApiVirusReportsByTaxonRequest {
	r.filterGeoLocation = &filterGeoLocation
	return r
}
// only include complete genomes.
func (r *ApiVirusReportsByTaxonRequest) FilterCompleteOnly(filterCompleteOnly bool) *ApiVirusReportsByTaxonRequest {
	r.filterCompleteOnly = &filterCompleteOnly
	return r
}
// Return either virus genome accessions, or complete virus metadata
func (r *ApiVirusReportsByTaxonRequest) ReturnedContent(returnedContent V1VirusDataReportRequestContentType) *ApiVirusReportsByTaxonRequest {
	r.returnedContent = &returnedContent
	return r
}
// Specify which fields to include in the tabular report
func (r *ApiVirusReportsByTaxonRequest) TableFields(tableFields []string) *ApiVirusReportsByTaxonRequest {
	r.tableFields = &tableFields
	return r
}
// The maximum number of virus data reports to return. Default is 20 and maximum is 1000. If the number of results exceeds the page size, &#x60;page_token&#x60; can be used to retrieve the remaining results.
func (r *ApiVirusReportsByTaxonRequest) PageSize(pageSize int32) *ApiVirusReportsByTaxonRequest {
	r.pageSize = &pageSize
	return r
}
// A page token is returned from a &#x60;GetVirusDataReports&#x60; call with more than &#x60;page_size&#x60; results. Use this token, along with the previous &#x60;VirusDataReportRequest&#x60; parameters, to retrieve the next page of results. When &#x60;page_token&#x60; is empty, all results have been retrieved.
func (r *ApiVirusReportsByTaxonRequest) PageToken(pageToken string) *ApiVirusReportsByTaxonRequest {
	r.pageToken = &pageToken
	return r
}

func (r ApiVirusReportsByTaxonRequest) Execute() (V1reportsVirusDataReportPage, *_nethttp.Response, error) {
	return r.ApiService.VirusReportsByTaxonExecute(r)
}

/*
VirusReportsByTaxon Get virus metadata by taxon

Get virus metadata by taxon. By default, in paged JSON format, but also available as tabular (accept: x-tabular) or json-lines (accept: x-jsonlines)
 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 @return ApiVirusReportsByTaxonRequest
*/
func (a *VirusApiService) VirusReportsByTaxon(ctx _context.Context, taxon string) ApiVirusReportsByTaxonRequest {
	return ApiVirusReportsByTaxonRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

// Execute executes the request
//  @return V1reportsVirusDataReportPage
func (a *VirusApiService) VirusReportsByTaxonExecute(r ApiVirusReportsByTaxonRequest) (V1reportsVirusDataReportPage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1reportsVirusDataReportPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusReportsByTaxon")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/dataset_report"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filterRefseqOnly != nil {
		localVarQueryParams.Add("filter.refseq_only", parameterToString(*r.filterRefseqOnly, ""))
	}
	if r.filterAnnotatedOnly != nil {
		localVarQueryParams.Add("filter.annotated_only", parameterToString(*r.filterAnnotatedOnly, ""))
	}
	if r.filterReleasedSince != nil {
		localVarQueryParams.Add("filter.released_since", parameterToString(*r.filterReleasedSince, ""))
	}
	if r.filterUpdatedSince != nil {
		localVarQueryParams.Add("filter.updated_since", parameterToString(*r.filterUpdatedSince, ""))
	}
	if r.filterHost != nil {
		localVarQueryParams.Add("filter.host", parameterToString(*r.filterHost, ""))
	}
	if r.filterPangolinClassification != nil {
		localVarQueryParams.Add("filter.pangolin_classification", parameterToString(*r.filterPangolinClassification, ""))
	}
	if r.filterGeoLocation != nil {
		localVarQueryParams.Add("filter.geo_location", parameterToString(*r.filterGeoLocation, ""))
	}
	if r.filterCompleteOnly != nil {
		localVarQueryParams.Add("filter.complete_only", parameterToString(*r.filterCompleteOnly, ""))
	}
	if r.returnedContent != nil {
		localVarQueryParams.Add("returned_content", parameterToString(*r.returnedContent, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	if r.pageToken != nil {
		localVarQueryParams.Add("page_token", parameterToString(*r.pageToken, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/tab-separated-values"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// override localVarHeaderParams with the headers passed into the function
	if len(r.Headers) > 0 {
		for k, v := range r.Headers { 
			localVarHeaderParams[k] = v
		}
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
