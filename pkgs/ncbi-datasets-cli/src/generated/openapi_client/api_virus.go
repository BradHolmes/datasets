/*
 * NCBI Datasets API
 *
 * ### NCBI Datasets is a resource that lets you easily gather data from NCBI. The Datasets API is still in alpha, and we're updating it often to add new functionality, iron out bugs and enhance usability. For some larger downloads, you may want to download a [dehydrated bag](https://www.ncbi.nlm.nih.gov/datasets/docs/rehydrate/), and retrieve the individual data files at a later time. 
 *
 * API version: v1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package datasets

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
	"time"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// VirusApiService VirusApi service
type VirusApiService service

type ApiSars2ProteinDownloadRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	proteins []string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	host *string
	geoLocation *string
	completeOnly *bool
	includeAnnotationType *[]V1AnnotationForVirusType
	filename *string
}

func (r *ApiSars2ProteinDownloadRequest) RefseqOnly(refseqOnly bool) *ApiSars2ProteinDownloadRequest {
	r.refseqOnly = &refseqOnly
	return r
}
func (r *ApiSars2ProteinDownloadRequest) AnnotatedOnly(annotatedOnly bool) *ApiSars2ProteinDownloadRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
func (r *ApiSars2ProteinDownloadRequest) ReleasedSince(releasedSince time.Time) *ApiSars2ProteinDownloadRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiSars2ProteinDownloadRequest) Host(host string) *ApiSars2ProteinDownloadRequest {
	r.host = &host
	return r
}
func (r *ApiSars2ProteinDownloadRequest) GeoLocation(geoLocation string) *ApiSars2ProteinDownloadRequest {
	r.geoLocation = &geoLocation
	return r
}
func (r *ApiSars2ProteinDownloadRequest) CompleteOnly(completeOnly bool) *ApiSars2ProteinDownloadRequest {
	r.completeOnly = &completeOnly
	return r
}
func (r *ApiSars2ProteinDownloadRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForVirusType) *ApiSars2ProteinDownloadRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}
func (r *ApiSars2ProteinDownloadRequest) Filename(filename string) *ApiSars2ProteinDownloadRequest {
	r.filename = &filename
	return r
}

func (r ApiSars2ProteinDownloadRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.Sars2ProteinDownloadExecute(r)
}

/*
 * Sars2ProteinDownload Download SARS-CoV-2 protein and CDS datasets by protein name
 * Download a SARS-CoV-2 protein datasets
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param proteins Which proteins to retrieve in the data package
 * @return ApiSars2ProteinDownloadRequest
 */
func (a *VirusApiService) Sars2ProteinDownload(ctx _context.Context, proteins []string) ApiSars2ProteinDownloadRequest {
	return ApiSars2ProteinDownloadRequest{
		ApiService: a,
		ctx: ctx,
		proteins: proteins,
	}
}

/*
 * Execute executes the request
 * @return *os.File
 */
func (a *VirusApiService) Sars2ProteinDownloadExecute(r ApiSars2ProteinDownloadRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinDownload")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein/{proteins}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"proteins"+"}", _neturl.PathEscape(parameterToString(r.proteins, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSars2ProteinSummaryRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	proteins []string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	host *string
	geoLocation *string
	completeOnly *bool
	includeAnnotationType *[]V1AnnotationForVirusType
}

func (r *ApiSars2ProteinSummaryRequest) RefseqOnly(refseqOnly bool) *ApiSars2ProteinSummaryRequest {
	r.refseqOnly = &refseqOnly
	return r
}
func (r *ApiSars2ProteinSummaryRequest) AnnotatedOnly(annotatedOnly bool) *ApiSars2ProteinSummaryRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
func (r *ApiSars2ProteinSummaryRequest) ReleasedSince(releasedSince time.Time) *ApiSars2ProteinSummaryRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiSars2ProteinSummaryRequest) Host(host string) *ApiSars2ProteinSummaryRequest {
	r.host = &host
	return r
}
func (r *ApiSars2ProteinSummaryRequest) GeoLocation(geoLocation string) *ApiSars2ProteinSummaryRequest {
	r.geoLocation = &geoLocation
	return r
}
func (r *ApiSars2ProteinSummaryRequest) CompleteOnly(completeOnly bool) *ApiSars2ProteinSummaryRequest {
	r.completeOnly = &completeOnly
	return r
}
func (r *ApiSars2ProteinSummaryRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForVirusType) *ApiSars2ProteinSummaryRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

func (r ApiSars2ProteinSummaryRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.Sars2ProteinSummaryExecute(r)
}

/*
 * Sars2ProteinSummary Summary of SARS-CoV-2 protein and CDS datasets by protein name
 * Download a summary of available SARS-CoV-2 protein datasets
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param proteins Which proteins to retrieve in the data package
 * @return ApiSars2ProteinSummaryRequest
 */
func (a *VirusApiService) Sars2ProteinSummary(ctx _context.Context, proteins []string) ApiSars2ProteinSummaryRequest {
	return ApiSars2ProteinSummaryRequest{
		ApiService: a,
		ctx: ctx,
		proteins: proteins,
	}
}

/*
 * Execute executes the request
 * @return V1DownloadSummary
 */
func (a *VirusApiService) Sars2ProteinSummaryExecute(r ApiSars2ProteinSummaryRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein/{proteins}"
	localVarPath = strings.Replace(localVarPath, "{"+"proteins"+"}", _neturl.PathEscape(parameterToString(r.proteins, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSars2ProteinTableRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	proteins []string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	host *string
	geoLocation *string
	completeOnly *bool
	tableFields *[]V1VirusTableField
	format *V1TableFormat
}

func (r *ApiSars2ProteinTableRequest) RefseqOnly(refseqOnly bool) *ApiSars2ProteinTableRequest {
	r.refseqOnly = &refseqOnly
	return r
}
func (r *ApiSars2ProteinTableRequest) AnnotatedOnly(annotatedOnly bool) *ApiSars2ProteinTableRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
func (r *ApiSars2ProteinTableRequest) ReleasedSince(releasedSince time.Time) *ApiSars2ProteinTableRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiSars2ProteinTableRequest) Host(host string) *ApiSars2ProteinTableRequest {
	r.host = &host
	return r
}
func (r *ApiSars2ProteinTableRequest) GeoLocation(geoLocation string) *ApiSars2ProteinTableRequest {
	r.geoLocation = &geoLocation
	return r
}
func (r *ApiSars2ProteinTableRequest) CompleteOnly(completeOnly bool) *ApiSars2ProteinTableRequest {
	r.completeOnly = &completeOnly
	return r
}
func (r *ApiSars2ProteinTableRequest) TableFields(tableFields []V1VirusTableField) *ApiSars2ProteinTableRequest {
	r.tableFields = &tableFields
	return r
}
func (r *ApiSars2ProteinTableRequest) Format(format V1TableFormat) *ApiSars2ProteinTableRequest {
	r.format = &format
	return r
}

func (r ApiSars2ProteinTableRequest) Execute() (V1TabularOutput, *_nethttp.Response, error) {
	return r.ApiService.Sars2ProteinTableExecute(r)
}

/*
 * Sars2ProteinTable Get SARS-CoV-2 protein metadata in a tabular format.
 * Get protein metadata in tabular format for SARS-CoV-2 genomes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param proteins Which proteins to retrieve in the data package
 * @return ApiSars2ProteinTableRequest
 */
func (a *VirusApiService) Sars2ProteinTable(ctx _context.Context, proteins []string) ApiSars2ProteinTableRequest {
	return ApiSars2ProteinTableRequest{
		ApiService: a,
		ctx: ctx,
		proteins: proteins,
	}
}

/*
 * Execute executes the request
 * @return V1TabularOutput
 */
func (a *VirusApiService) Sars2ProteinTableExecute(r ApiSars2ProteinTableRequest) (V1TabularOutput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1TabularOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.Sars2ProteinTable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/sars2/protein/{proteins}/table"
	localVarPath = strings.Replace(localVarPath, "{"+"proteins"+"}", _neturl.PathEscape(parameterToString(r.proteins, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusGenomeDownloadRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	taxon string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	host *string
	pangolinClassification *string
	geoLocation *string
	completeOnly *bool
	excludeSequence *bool
	includeAnnotationType *[]V1AnnotationForVirusType
	filename *string
}

func (r *ApiVirusGenomeDownloadRequest) RefseqOnly(refseqOnly bool) *ApiVirusGenomeDownloadRequest {
	r.refseqOnly = &refseqOnly
	return r
}
func (r *ApiVirusGenomeDownloadRequest) AnnotatedOnly(annotatedOnly bool) *ApiVirusGenomeDownloadRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
func (r *ApiVirusGenomeDownloadRequest) ReleasedSince(releasedSince time.Time) *ApiVirusGenomeDownloadRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiVirusGenomeDownloadRequest) Host(host string) *ApiVirusGenomeDownloadRequest {
	r.host = &host
	return r
}
func (r *ApiVirusGenomeDownloadRequest) PangolinClassification(pangolinClassification string) *ApiVirusGenomeDownloadRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}
func (r *ApiVirusGenomeDownloadRequest) GeoLocation(geoLocation string) *ApiVirusGenomeDownloadRequest {
	r.geoLocation = &geoLocation
	return r
}
func (r *ApiVirusGenomeDownloadRequest) CompleteOnly(completeOnly bool) *ApiVirusGenomeDownloadRequest {
	r.completeOnly = &completeOnly
	return r
}
func (r *ApiVirusGenomeDownloadRequest) ExcludeSequence(excludeSequence bool) *ApiVirusGenomeDownloadRequest {
	r.excludeSequence = &excludeSequence
	return r
}
func (r *ApiVirusGenomeDownloadRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForVirusType) *ApiVirusGenomeDownloadRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}
func (r *ApiVirusGenomeDownloadRequest) Filename(filename string) *ApiVirusGenomeDownloadRequest {
	r.filename = &filename
	return r
}

func (r ApiVirusGenomeDownloadRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.VirusGenomeDownloadExecute(r)
}

/*
 * VirusGenomeDownload Download Coronavirus genome datasets by taxon
 * Download a Coronavirus genome datasets by taxon
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 * @return ApiVirusGenomeDownloadRequest
 */
func (a *VirusApiService) VirusGenomeDownload(ctx _context.Context, taxon string) ApiVirusGenomeDownloadRequest {
	return ApiVirusGenomeDownloadRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

/*
 * Execute executes the request
 * @return *os.File
 */
func (a *VirusApiService) VirusGenomeDownloadExecute(r ApiVirusGenomeDownloadRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeDownload")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/genome/download"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.excludeSequence != nil {
		localVarQueryParams.Add("exclude_sequence", parameterToString(*r.excludeSequence, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	if r.filename != nil {
		localVarQueryParams.Add("filename", parameterToString(*r.filename, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusGenomeSummaryRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	taxon string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	host *string
	pangolinClassification *string
	geoLocation *string
	completeOnly *bool
	excludeSequence *bool
	includeAnnotationType *[]V1AnnotationForVirusType
}

func (r *ApiVirusGenomeSummaryRequest) RefseqOnly(refseqOnly bool) *ApiVirusGenomeSummaryRequest {
	r.refseqOnly = &refseqOnly
	return r
}
func (r *ApiVirusGenomeSummaryRequest) AnnotatedOnly(annotatedOnly bool) *ApiVirusGenomeSummaryRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
func (r *ApiVirusGenomeSummaryRequest) ReleasedSince(releasedSince time.Time) *ApiVirusGenomeSummaryRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiVirusGenomeSummaryRequest) Host(host string) *ApiVirusGenomeSummaryRequest {
	r.host = &host
	return r
}
func (r *ApiVirusGenomeSummaryRequest) PangolinClassification(pangolinClassification string) *ApiVirusGenomeSummaryRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}
func (r *ApiVirusGenomeSummaryRequest) GeoLocation(geoLocation string) *ApiVirusGenomeSummaryRequest {
	r.geoLocation = &geoLocation
	return r
}
func (r *ApiVirusGenomeSummaryRequest) CompleteOnly(completeOnly bool) *ApiVirusGenomeSummaryRequest {
	r.completeOnly = &completeOnly
	return r
}
func (r *ApiVirusGenomeSummaryRequest) ExcludeSequence(excludeSequence bool) *ApiVirusGenomeSummaryRequest {
	r.excludeSequence = &excludeSequence
	return r
}
func (r *ApiVirusGenomeSummaryRequest) IncludeAnnotationType(includeAnnotationType []V1AnnotationForVirusType) *ApiVirusGenomeSummaryRequest {
	r.includeAnnotationType = &includeAnnotationType
	return r
}

func (r ApiVirusGenomeSummaryRequest) Execute() (V1DownloadSummary, *_nethttp.Response, error) {
	return r.ApiService.VirusGenomeSummaryExecute(r)
}

/*
 * VirusGenomeSummary Get summary data for Coronaviridae genomes by taxon
 * Get summary data and download by command line instructions for Coronaviridae genomes by taxon.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 * @return ApiVirusGenomeSummaryRequest
 */
func (a *VirusApiService) VirusGenomeSummary(ctx _context.Context, taxon string) ApiVirusGenomeSummaryRequest {
	return ApiVirusGenomeSummaryRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

/*
 * Execute executes the request
 * @return V1DownloadSummary
 */
func (a *VirusApiService) VirusGenomeSummaryExecute(r ApiVirusGenomeSummaryRequest) (V1DownloadSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1DownloadSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/genome"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.excludeSequence != nil {
		localVarQueryParams.Add("exclude_sequence", parameterToString(*r.excludeSequence, ""))
	}
	if r.includeAnnotationType != nil {
		t := *r.includeAnnotationType
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("include_annotation_type", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("include_annotation_type", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVirusGenomeTableRequest struct {
	ctx _context.Context
	ApiService *VirusApiService
	taxon string
	refseqOnly *bool
	annotatedOnly *bool
	releasedSince *time.Time
	host *string
	pangolinClassification *string
	geoLocation *string
	completeOnly *bool
	tableFields *[]V1VirusTableField
	format *V1TableFormat
}

func (r *ApiVirusGenomeTableRequest) RefseqOnly(refseqOnly bool) *ApiVirusGenomeTableRequest {
	r.refseqOnly = &refseqOnly
	return r
}
func (r *ApiVirusGenomeTableRequest) AnnotatedOnly(annotatedOnly bool) *ApiVirusGenomeTableRequest {
	r.annotatedOnly = &annotatedOnly
	return r
}
func (r *ApiVirusGenomeTableRequest) ReleasedSince(releasedSince time.Time) *ApiVirusGenomeTableRequest {
	r.releasedSince = &releasedSince
	return r
}
func (r *ApiVirusGenomeTableRequest) Host(host string) *ApiVirusGenomeTableRequest {
	r.host = &host
	return r
}
func (r *ApiVirusGenomeTableRequest) PangolinClassification(pangolinClassification string) *ApiVirusGenomeTableRequest {
	r.pangolinClassification = &pangolinClassification
	return r
}
func (r *ApiVirusGenomeTableRequest) GeoLocation(geoLocation string) *ApiVirusGenomeTableRequest {
	r.geoLocation = &geoLocation
	return r
}
func (r *ApiVirusGenomeTableRequest) CompleteOnly(completeOnly bool) *ApiVirusGenomeTableRequest {
	r.completeOnly = &completeOnly
	return r
}
func (r *ApiVirusGenomeTableRequest) TableFields(tableFields []V1VirusTableField) *ApiVirusGenomeTableRequest {
	r.tableFields = &tableFields
	return r
}
func (r *ApiVirusGenomeTableRequest) Format(format V1TableFormat) *ApiVirusGenomeTableRequest {
	r.format = &format
	return r
}

func (r ApiVirusGenomeTableRequest) Execute() (V1TabularOutput, *_nethttp.Response, error) {
	return r.ApiService.VirusGenomeTableExecute(r)
}

/*
 * VirusGenomeTable Get viral genomic metadata in a tabular format.
 * Get viral genomic metadata in tabular format for Coronaviridae genomes by taxon.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taxon NCBI Taxonomy ID or name (common or scientific) at any taxonomic rank
 * @return ApiVirusGenomeTableRequest
 */
func (a *VirusApiService) VirusGenomeTable(ctx _context.Context, taxon string) ApiVirusGenomeTableRequest {
	return ApiVirusGenomeTableRequest{
		ApiService: a,
		ctx: ctx,
		taxon: taxon,
	}
}

/*
 * Execute executes the request
 * @return V1TabularOutput
 */
func (a *VirusApiService) VirusGenomeTableExecute(r ApiVirusGenomeTableRequest) (V1TabularOutput, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1TabularOutput
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VirusApiService.VirusGenomeTable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/virus/taxon/{taxon}/genome/table"
	localVarPath = strings.Replace(localVarPath, "{"+"taxon"+"}", _neturl.PathEscape(parameterToString(r.taxon, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refseqOnly != nil {
		localVarQueryParams.Add("refseq_only", parameterToString(*r.refseqOnly, ""))
	}
	if r.annotatedOnly != nil {
		localVarQueryParams.Add("annotated_only", parameterToString(*r.annotatedOnly, ""))
	}
	if r.releasedSince != nil {
		localVarQueryParams.Add("released_since", parameterToString(*r.releasedSince, ""))
	}
	if r.host != nil {
		localVarQueryParams.Add("host", parameterToString(*r.host, ""))
	}
	if r.pangolinClassification != nil {
		localVarQueryParams.Add("pangolin_classification", parameterToString(*r.pangolinClassification, ""))
	}
	if r.geoLocation != nil {
		localVarQueryParams.Add("geo_location", parameterToString(*r.geoLocation, ""))
	}
	if r.completeOnly != nil {
		localVarQueryParams.Add("complete_only", parameterToString(*r.completeOnly, ""))
	}
	if r.tableFields != nil {
		t := *r.tableFields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("table_fields", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("table_fields", parameterToString(t, "multi"))
		}
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuthHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}
	if localVarHTTPResponse.Header.Get("Content-Type") != "application/json" {
		return localVarReturnValue, localVarHTTPResponse, nil
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
